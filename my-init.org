#+TITLE:  Brandon's Emacs Init
#+PROPERTY: header-args :results output silent

My emacs init file.

Much of this has been pulled from other projects/init/EmacsWiki files
in the emacs community, and to the best of my knowledge, the original
source for each section has been attributed. Please let me know if you
find missing or incorrect attributions!

* Localization (pre-package)

Set config variables on a per-system basis.

|--------------+--------------------------------------------------------------------------------|
| *use-frames* | Whether or not to tune use frame-oriented options in emacs. StumpWM is assumed |
| *commit-org* | Whether we should git-commit after saving all org buffers.                     |
|--------------+--------------------------------------------------------------------------------|

#+BEGIN_SRC emacs-lisp
(defvar my:use-frames nil)
(defvar my:commit-org nil)

(pcase (system-name)

  ;; x230
  ("brandon-babypad-linux"
    (progn
      (setq my:use-frames nil
            my:commit-org t)
      (set-face-attribute 'default nil :height 70)))

  ;; P51
  ("brandon-thinkpad-archlinux"
    (set-face-attribute 'default nil :height 75))

  ;; Desktop VM on home server
  ("remote-workstation"
    ))
#+END_SRC

Utility function to shorten tests against Emacs 27 release.

#+BEGIN_SRC emacs-lisp
(defun e27-p ()
  (>= emacs-major-version 27))
#+END_SRC

* Required Packages
This section ensures that all required packages are loaded.

** Package System Config

Initialize the package system. Tell emacs to load the newest version of anything it looks for (IE, if there's a foo.el and foo.elc, take the newest one).

#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'load-path "~/.emacs.d/emacs-config/lisp/")
(add-to-list 'load-path "~/.emacs.d/elpa/")

(add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)

(customize-set-variable 'load-prefer-newer t)
(package-initialize)
(setq package-enable-at-startup nil)
#+END_SRC

Require a package, install it if it is not present. This is from
[[https://www.draketo.de/light/english/emacs/babcore][babcore]].

TODO: Consider =use-package=. It can predicate package loads on system
binaries (and install them too), and this solution doesn't work if the
package name in (M)ELPA is different than provide statement in the
package.

#+BEGIN_SRC emacs-lisp
(defvar refreshed-packages nil)
(defun package-require (package)
  "Require package, install if needed."
  (package-activate package '(0))
  (condition-case nil (require package)
    (progn
      (if (not refreshed-packages)
          (progn
            (package-refresh-contents)
            (setq refreshed-packages t))))
      (error (package-install package))))
#+END_SRC

** Package List

The actual package list.

#+BEGIN_SRC emacs-lisp
  (package-require 'buffer-move)           ; swap buffers between adjacent windows
  (package-require 'diff-hl)               ; show changes from last commit with edge highlighting
  (package-require 'uniquify)              ; rename buffers of same name intelligently
  (package-require 'undo-tree)             ; incredible undo/redo support
  (package-require 'auto-complete)         ; neat autocompletion
  (package-require 'framemove)             ; jump between frames and windows
  (package-require 'fuzzy)                 ; fuzzy completion
  (package-require 'hi-lock)               ; arbitrary text hilighting
  (package-require 'button-lock)           ; face attribute that makes links from text
  (package-require 'bm)                    ; bookmark manager
  (package-require 'yasnippet)             ; snippet pasting framework
  (package-require 'anzu)                  ; show total/current matches in isearch
  (package-require 'visual-regexp)         ; visualize regular expressions in real-time
  (package-require 'expand-region)         ; Expand region
  (package-require 'origami)               ; awesome code folding
  (package-require 'general)               ; sane key mapping architecture
  (package-require 'which-key)             ; Display options after prefix keys are entered
  (package-require 'ivy)                   ; Awesome completion framework
  (package-require 'swiper)                ; ivy's swoop
  (package-require 'counsel)               ; too many ivy-based utilities to list
  (package-require 'hy-mode)               ; Lisp on Python
  (package-require 'org-autolist)          ; Automatically add bullets on return
  (package-require 'pdf-tools)             ; excellent PDF viewer, replaces docview
  (package-require 'ob-ipython)            ; powerful jupyter notebooks alternative
  (package-require 'pyvenv)                ; make conda envs usable with ob-ipython (and, well, everything else)
  (package-require 'emojify)               ; emoji support
  (package-require 'unicode-fonts)         ; better unicode support
  (package-require 'persistent-soft)       ; caching for unicode mappings
  (package-require 'google-translate)      ; translations
  (package-require 'auto-highlight-symbol) ; highlight the thing under cursor, jump between occurrences
  (package-require 'org-bullets)           ; unicode, indented bullets for org-mode headings
  (package-require 'calfw)                 ; emacs calendar framework
  (package-require 'calfw-org)             ; org-mode calendar support for calfw
  (package-require 'org-caldav)            ; caldav support for emacs
  (package-require 'yequake)               ; quake-style dropdown emacs frame
  (package-require 'flymd)                 ; markdown to html rendering in elisp
  (package-require 'hy-mode)               ; lisp via python
  (package-require 'all-the-icons)         ; icon set for emacs
  (package-require 'all-the-icons-ivy)     ; use icons in buffer switching
  (package-require 'jedi)                  ; python completions
  (package-require 'poporg)                ; inside-out org-babel -- edit comments in source code as org-mode content
  (package-require 'camcorder)             ; record frames to ogv or gif
  (package-require 'slime)                 ; common lisp debugging and interaction
  (package-require 'es-mode)               ; Elasticsearch support in emacs
  (package-require 'battery)               ; Battery life info
  (package-require 'emms-setup)            ; music player in emacs
  (package-require 'hydra)                 ; persistent key submaps
  (package-require 'ess)                   ; emacs speaks statistics -- R support
  (package-require 'conda)                 ; Support for anaconda environments
  (package-require 'treemacs)              ; Advanced folder/file/content browser
  (package-require 'notmuch)               ; reading emails
  (package-require 'smtpmail)              ; sending emails
  (package-require 'lsp-mode)              ; language server protocol support
  (package-require 'ccls)                  ; C/C++/OBJC LSP backend
  (package-require 'olivetti)              ; Center text with fill-columns, critical for large displays.
  (package-require 'rainbow-delimiters)    ; Colorize matched parens, brackets, etc.
  (package-require 'dired-x)               ; Dired improvements (distributed with emacs, but manually loaded)
  (package-require 'helm-descbinds)        ; Extremely useful for learning new major modes.
  (package-require 'magit)                 ; Incredible Git client interface in emacs
  (package-require 'emmet-mode)            ; HTML editing mode which generates HTML from CSS-like expressions
  (package-require 'smex)                  ; Maintain M-x history -- automatically used by counsel-M-x
  (package-require 'csv-mode)              ; Display CSV files in proper columns
  (package-require 'narrow-indirect)       ; Make indirect buffer in new window, then narrow to region
  (package-require 'iedit)                 ; Highlight and edit all occurences of symbol under point
  (package-require 'ac-slime)              ; autocompletion for SLIME
  (package-require 'clhs)                  ; Lookup symbol in Common Lisp Hyper Spec
  (package-require 'fence-edit)            ; Edit regions of one buffer in another buffer (usually with different major mode)
  (package-require 'ivy-posframe)          ; Move minibuffer to child frame
  (package-require 'counsel-notmuch)       ; Search notmuch emails with ivy
  (package-require 'ts)                    ; Timestamp utility functions for org-mode
  (package-require 'auto-yasnippet)        ; On the fly text templating
  (package-require 'plantuml-mode)         ; Edit plantuml files; UML generation from plain text.
  (package-require 'vterm)                 ; A more compatible terminal emulator for emacs via libvterm
  (package-require 'org-ql)                ; A sane interface for finding things in Org
#+END_SRC

* Localization (post-package)

Specify paths to basic utilities on Windows 7 systems (just use WSL on
windows 10).

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (progn
    (setq
      find-program        "\"C:/Program Files (x86)/Git/bin/find.exe\""
      grep-program        "\"C:/Program Files (x86)/Git/bin/grep.exe\""
      diff-program        "\"C:/Program Files (x86)/Git/bin/diff.exe\""
      diff-command        "\"C:/Program Files (x86)/Git/bin/diff.exe\""
      git-program         "\"C:/Program Files (x86)/Git/bin/git.exe\""
      ispell-program-name "\"C:/Program Files (x86)/Aspell/bin/aspell.exe\""
      scheme-program      "\"C:/Program Files (x86)/MIT-GNU Scheme/bin/mit-scheme.exe\""
      ctags-bin-name      "\"C:/Program Files (x86)/ctags/ctags.exe\"")
    (add-to-list 'exec-path "C:/cygwin64/bin")
    (add-to-list 'exec-path "C:/Program Files (x86)/Git/bin")
    (setenv "PATH" (concat "C:\\Program Files (x86)\\Git\\bin;" (getenv "PATH")))
    (setenv "CYGWIN" "nodosfilewarning") ;; I don't remember but this did, but I remember it being very frustrating
    (setenv "WORKON_HOME" "C:/Users/guttersohn/AppData/Local/conda/conda/envs/py36_64/") ;; don't use the weird preloaded Python 2.7
    (pyvenv-mode 1)))
#+END_SRC

Special hacks for Windows

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (progn
    (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
    (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)))
#+END_SRC

* Key Mappings
** Background
Most of my custom key-bindings use the hyper key. The goal here is to
prevent any reasonable possibility of collision between personal
keybindings and package keybindings. By convention, C-<key> is already
reserved for the user, but we have another modifier available anyway,
so why not use it? In my case, the hyper modifier is bound to caps
lock.

To map caps lock to hyper under Xorg, you may do the following in ~/.Xmodmap:

#+BEGIN_SRC bash
clear mod4
keycode 66 = Hyper_L
add mod4 = Super_L Super_R
clear lock
add mod3 = Hyper_L
#+END_SRC

In windows, install AutoHotkey, and place the following in a startup
script...

#+BEGIN_SRC autohotkey
SetTitleMatchMode, 2
#IfWinActive emacs-nt
{
    CapsLock::AppsKey
    return
}
#+END_SRC

...with the following elisp...

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (setq w32-pass-lwindow-to-system nil
        w32-pass-rwindow-to-system nil
        w32-pass-apps-to-system nil
        w32-lwindow-modifier 'super
        w32-rwindow-modifier 'super
        w32-apps-modifier 'hyper))
#+END_SRC

Do note that this leaves the apps key unusable in emacs, except as a
secondary hyper modifier. I have not yet found another way to do this
which works well for me.

** Functions

Functions designed specifically to be used as key mappings.

*** C stuff

Tab key rebinding.

#+BEGIN_SRC emacs-lisp
(defun c-smart-tab-key ()
  "Indent when at left margin or right of whitespace, autocomplete elsewhere"
  (interactive)
  (smart-tab-key 'c-indent-line-or-region 'dabbrev-expand c-basic-offset))
#+END_SRC

*** Window stuff.

Defined to balance existing function names.

#+BEGIN_SRC emacs-lisp
(defun split-window-above ()
  "Split current window into top and bottom, with focus left in bottom."
  (interactive)
  (split-window-below)
  (windmove-down))

(defun split-window-left ()
  "Split current window into left and right, with focus left in right."
  (interactive)
  (split-window-right)
  (windmove-right))
#+END_SRC

*** Text stuff

#+BEGIN_SRC emacs-lisp
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
      ;; This would override `fill-column' if it's an integer.
      (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

(defun smart-beginning-of-line ()
  "Move point to first non-whitespace character or beginning-of-line.
   Move point to the first non-whitespace character on this line.
   If point was already at that position, move point to beginning of line.
   https://www.emacswiki.org/emacs/BackToIndentationOrBeginning#toc2"
  (interactive) ; Use (interactive "^") in Emacs 23 to make shift-select work
  (let ((oldpos (point)))
    (back-to-indentation)
    (and (= oldpos (point))
         (beginning-of-line))))

(defun smart-copy-paste ()
  "Smart copy or paste"
  (interactive)
  (if (use-region-p)
      (if (and (boundp 'rectangle-mark-mode) rectangle-mark-mode)
          (copy-rectangle-as-kill (region-beginning) (region-end))
        (kill-ring-save (region-beginning) (region-end)))
    (yank)))

(defun smart-set-mark ()
  "Consecutive calls expand region. First sets mark."
  (interactive)
  (if mark-active
    (call-interactively 'er/expand-region)
  (call-interactively 'set-mark-command)))

(defun smart-cut-or-delete ()
  "If region, cut, else, delete char"
  (interactive)
  (if (use-region-p)
    (kill-region (region-beginning) (region-end))
    (delete-forward-char 1)))

(defun execute-command-toggle (prefixes)
  "If region active, clear it. Else, toggle the M-x menu."
  (interactive "P")
  (cond
    ((window-minibuffer-p)                    (my:keyboard-escape-quit))
    (mark-active                              (progn (setq mark-active nil) (run-hooks 'deactivate-mark-hook)))
    (t                                        (counsel-M-x prefixes))))

(defun execute-command-toggle-ignore-region (prefixes)
  "Toggle M-x menu."
  (interactive "P")
  (if (window-minibuffer-p)
      (my:keyboard-escape-quit)
    (counsel-M-x prefixes)))

(defun whack-whitespace-after-point (arg)
  ;; https://www.emacswiki.org/emacs/DeletingWhitespace
  "Delete all white space from point to the next word.  With prefix ARG
  delete across newlines as well.  The only danger in this is that you
  don't have to actually be at the end of a word to make it work.  It
  skips over to the next whitespace and then whacks it all to the next
  word."
  ;; (interactive "P")
    (let ((regexp (if arg "[ \t\n]+" "[ \t]+")))
      (re-search-forward regexp nil t)
      (replace-match "" nil nil)))

(defun smart-batch-delete ()
  (interactive)
  (if (or (looking-at "$") (looking-at " "))
      (whack-whitespace-after-point t)
    (kill-word nil)))

(defun my:comment-region-or-line ()
  "If region active, comment it. Else, comment current line."
  (interactive)
  (call-interactively (if (use-region-p)
        'comment-or-uncomment-region
      'comment-line)))

(defun my:comment-region-or-line-keep-clone ()
  "Copy the current line or region below, then comment out the original."
  (interactive)
  (let (beg end)
    (if (use-region-p)

      ;; If region is active, make sure that it starts at the start
      ;; of a line, and ends at the end of another line.
      (let ((temp-beg (region-beginning))
            (temp-end (region-end)))
        (save-excursion
          (goto-char temp-beg)
          (beginning-of-line)
          (setq beg (point))
          (goto-char temp-end)
          (end-of-line)
          (setq end (point))))

      ;; Just set beg and end to the extents of the current line
      (save-excursion
        (beginning-of-line)
        (setq beg (point))
        (end-of-line)
        (setq end (point))))

    ;; Select region, copy it, comment it, paste it below
    (save-excursion
      (set-mark beg)
      (goto-char end)
      (activate-mark)
      (copy-region-as-kill beg end)
      (my:comment-region-or-line)
      (newline)
      (yank))

    ;; Place point at the start of the pasted area (probably)
    (forward-line)
    (smart-beginning-of-line)))

(defun newline-after-current ()
  "Skip to end of this line, insert a new one, autoindent, recenter cursor."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent)
  (scroll-up 1))

(defun newline-before-current ()
  "Move this line down, go to beginning of a new line where this one was."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (move-beginning-of-line nil)
  (when (looking-at "[ \t]+$")
    (kill-line)
    (setq kill-ring (cdr kill-ring))
    (insert "\n")
    (forward-line -1))
  (forward-line -1)
  (indent-for-tab-command))

(defun newline-before-and-after-current()
  "Insert new lines above and below current line."
  (interactive)
  (newline-after-current)
  (newline-before-current))

(defun previous-appropriate-buffer-if-hidden ()
  (previous-appropriate-buffer))

(defun hidden-buffer-p ()
  (or
   (string-match "\*.*\*" (buffer-name))      ; *buffer*s
   (string-match "^COM[0-9]*$" (buffer-name)) ; windows serial buffer
   (string-match "^/dev/tty*" (buffer-name))  ; *nix serial buffer
   (string-match "^TAGS$" (buffer-name))))    ; TAGS file

(defun next-non-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-non-sys-buffer-with-basecase 'next-buffer start-buffer)))

(defun previous-non-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-non-sys-buffer-with-basecase 'previous-buffer start-buffer)))

(defun next-non-sys-buffer-with-basecase (advance-f base)
  (funcall advance-f)
  (if (and
       (not (eq base (buffer-name)))
       (hidden-buffer-p))
      (next-non-sys-buffer-with-basecase advance-f base)))

(defun next-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-sys-buffer-with-basecase 'next-buffer start-buffer)))

(defun previous-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-sys-buffer-with-basecase 'previous-buffer start-buffer)))

(defun next-sys-buffer-with-basecase (advance-f base)
  (funcall advance-f)
  (if (and
       (not (eq base (buffer-name)))
       (not( hidden-buffer-p)))
      (next-sys-buffer-with-basecase advance-f base)))

(defun next-appropriate-buffer ()
  (interactive)
  (next-non-sys-buffer))

(defun previous-appropriate-buffer ()
  (interactive)
  (previous-non-sys-buffer))
#+END_SRC

Edit thing at point as source code using fence-edit.

#+begin_src emacs-lisp
  (defun my:edit-as-source ()
    "Like fence-edit-dwim, but always prompts for language."
    (interactive)
    (let* ((block (fence-edit--get-block-around-point))
           (beg (car block))
           (end (nth 1 block)))
      (save-mark-and-excursion
        (set-mark beg)
        (goto-char end)
        (activate-mark)
        (let ((current-prefix-arg '(4)))
          (call-interactively 'fence-edit-code-region)))))
#+end_src

*** Python Stuff
Run python in shell.

#+BEGIN_SRC emacs-lisp
(defun run-python-in-shell ()
  (interactive)
  (if (use-region-p)
      (call-interactively 'python-shell-send-region)
    (save-excursion
      (progn
        (beginning-of-line)
        (push-mark)
        (end-of-line)
        (call-interactively 'python-shell-send-region)
        (pop-mark)))))
#+END_SRC

Use counsel for jedi autocompletions, thanks to [[https://oremacs.com/2015/08/26/counsel-jedi/][abo-abo]].

#+BEGIN_SRC emacs-lisp
(defun counsel-jedi ()
  "Python completion at point."
  (interactive)
  (let ((bnd (bounds-of-thing-at-point 'symbol)))
    (if bnd
        (progn
          (setq counsel-completion-beg (car bnd))
          (setq counsel-completion-end (cdr bnd)))
      (setq counsel-completion-beg nil)
      (setq counsel-completion-end nil)))
  (deferred:sync!
   (jedi:complete-request))
  (ivy-read "Symbol name: " (jedi:ac-direct-matches)
            :action #'counsel--py-action))

(defun counsel--py-action (symbol)
  "Insert SYMBOL, erasing the previous one."
  (when (stringp symbol)
    (with-ivy-window
      (when counsel-completion-beg
        (delete-region
         counsel-completion-beg
         counsel-completion-end))
      (setq counsel-completion-beg
            (move-marker (make-marker) (point)))
      (insert symbol)
      (setq counsel-completion-end
            (move-marker (make-marker) (point)))
      (when (equal (get-text-property 0 'symbol symbol) "f")
        (insert "()")
        (setq counsel-completion-end
              (move-marker (make-marker) (point)))
        (backward-char 1)))))
#+END_SRC

Send the current "block" to inferior Python process.

#+BEGIN_SRC emacs-lisp
(defun python-shell-send-toplevel-thing-at-point ()
  (interactive)
  (save-mark-and-excursion
    (search-backward-regexp "\n\n\[^ \]+")
    (forward-char)
    (set-mark (point))
    (search-forward-regexp "\n\n\[^ \]+")
    (beginning-of-line)
    (python-shell-send-region (region-beginning) (region-end))))
#+END_SRC

*** Navigation Stuff

#+BEGIN_SRC emacs-lisp
(defun my:goto-previous-change ()
  (interactive)
  (diff-hl-previous-hunk)
  (recenter))

(defun my:goto-next-change ()
  (interactive)
  (diff-hl-next-hunk)
  (recenter))

(defun my:goto-line ()
  (interactive)
  (call-interactively 'goto-line)
  (recenter))

(defun my:annotated-bookmark ()
  (interactive)
  (let* ((bm-annotate-on-create t)) (bm-toggle)))

(defun my:scroll-up-some-lines ()
  (interactive)
  (if pixel-scroll-mode
      (pixel-scroll-up)
    (scroll-up 15)))

(defun my:scroll-down-some-lines ()
  (interactive)
  (if pixel-scroll-mode
      (pixel-scroll-down)
    (scroll-down 15)))

(defun my:scroll-left-some-lines ()
  (interactive)
  ;; invert axis
  (scroll-right 5))

(defun my:scroll-right-some-lines ()
  (interactive)
  ;; invert axis
  (scroll-left 5))
#+END_SRC

*** Keyboard Macro Stuff

#+BEGIN_SRC emacs-lisp
(defun my:run-or-save-macro (name)
  (if defining-kbd-macro
      (progn
        (kmacro-end-or-call-macro nil)
        (fset
         (intern (format "mcr-%s" name))
         last-kbd-macro))
    (execute-kbd-macro
     (intern
      (format "mcr-%s" name)))))

(defun my:run-macro (name)
  (execute-kbd-macro
     (intern
      (format "mcr-%s" name))))
#+END_SRC

*** Other Stuff

Revert buffer unconditionally;

#+BEGIN_SRC emacs-lisp
(defun my:revert-buffer-no-prompt ()
  "Revert buffer without confirmation. From https://emacs.stackexchange.com/questions/10348/revert-buffer-discard-unsaved-changes-without-y-n-prompt"
  (interactive) (revert-buffer t t))
#+END_SRC

Smart tab key framework

#+BEGIN_SRC emacs-lisp
(defun gen-smart-tab-key (indent autocomplete indent-count)
  (lexical-let
      ((indent indent)
       (autocomplete autocomplete)
       (indent-count indent-count))
    (lambda ()
      (interactive)
      (smart-tab-key indent autocomplete indent-count))))

(defun smart-tab-key (indent autocomplete indent-count)
"Indent when at left margin or right of whitespace, autocomplete elsewhere."
  (cond ((or (eq last-command 'yank) (eq last-command 'yank-pop)) (yank-pop))
        (( or
           (eq last-command 'find-tag)
           (eq last-command 'find-tag-other-window)
           (eq last-command 'find-tag-wrapped)
           (eq last-command 'find-tag-wrapped-new-window))
         (progn
           (let ((current-prefix-arg '(4)))
             (message "Finding next possible definition...")
             (call-interactively 'find-tag))
           (recenter-top-bottom)
           (setq this-command 'find-tag)))
        ((use-region-p) (indent-rigidly (region-beginning) (region-end) indent-count))
        ((or (= 0 (current-column)) (= ?\s (char-before))) (funcall indent))
        (t (call-interactively autocomplete))))

(defun generic-smart-tab-key ()
  "Indent when at left margin or right of whitespace, autocomplete elsewhere"
  (interactive)
  (smart-tab-key 'indent-for-tab-command 'dabbrev-expand 1))

(defun python-smart-tab-key ()
  "Indent when at left margin or right of whitespace, autocomplete elsewhere"
  (interactive)
  (smart-tab-key 'indent-for-tab-command 'dabbrev-expand 1))
#+END_SRC

Add a =write-file= wrapper which disables Ivy's automagic directory completion.

#+begin_src emacs-lisp
(defun my:save-as ()
  "Calls write-file, doesn't let Ivy autoselect directories upon slash."
  (interactive)
  (let
      ((ivy-magic-slash-non-match-action nil))
    (call-interactively 'write-file)))
#+end_src

*** org-mode

Refresh agenda after TODO change. This let's queued entries to be
shown quickly when the ORDERED property is set to t for a heading.

#+BEGIN_SRC emacs-lisp
(defun my:org-agenda-todo-and-redo ()
  "Call org-agenda-todo interactively, then org-agenda-redo"
  (interactive)
  (call-interactively 'org-agenda-todo)
  (org-agenda-redo))
#+END_SRC

Modify org-agenda-switch-to to respect the 'pop-up-buffers custom
variable. It will open a new frame or window when opening TODO items
in agenda views.

#+BEGIN_SRC emacs-lisp
(defun my:org-agenda-switch-to (&optional delete-other-windows)
  "Like normal org-agenda-switch-to, but respect pop-up-buffer by
using display-buffer in place of pop-to-buffer."
  (interactive)
  (if (and org-return-follows-link
	   (not (org-get-at-bol 'org-marker))
	   (org-in-regexp org-bracket-link-regexp))
      (org-open-link-from-string (match-string 0))
    (let* ((marker (or (org-get-at-bol 'org-marker)
		       (org-agenda-error)))
	   (buffer (marker-buffer marker))
	   (pos (marker-position marker)))
      (unless buffer (user-error "Trying to switch to non-existent buffer"))
      (display-buffer buffer) ;; <----------------------- MODIFIED LINE BJG
      (when delete-other-windows (delete-other-windows))
      (widen)
      (goto-char pos)
      (when (derived-mode-p 'org-mode)
	(org-show-context 'agenda)
	(run-hooks 'org-agenda-after-show-hook)))))
#+END_SRC

Toggle center-alignment & word-wrap (good for reading) in unison. Sometimes it's needed to keep tables formatted, which are too wide to fit in the normal fill-column but are fine in export.

#+BEGIN_SRC emacs-lisp
(defvar my:org-wrapped t)
(make-variable-buffer-local 'my:org-wrapped)

(defun my:org-toggle-wrap ()
  (interactive)
  (if my:org-wrapped
      (progn
        (olivetti-mode -1)
        (visual-line-mode -1))
    (progn
        (olivetti-mode 1)
        (visual-line-mode 1)))
  (setq my:org-wrapped (not my:org-wrapped)))
#+END_SRC

Ignore dependencies when I explicitly want to set status. I have dependency checking enabled only so that irrelevant goals are not cluttering my todo list. See =org-agenda-dim-blocked-tasks=.

#+BEGIN_SRC emacs-lisp
(defun my:org-todo ()
  "Like org-todo, but with `org-enforce-todo-dependencies' temporarily bound to nil"
  (interactive)
  (let ((org-enforce-todo-dependencies nil))
    (call-interactively #'org-todo)))
#+END_SRC

Function to interactively switch the currently clocked task. Modified from [[https://github.com/alphapapa/org-ql/issues/63][org-ql's github]].

#+BEGIN_SRC emacs-lisp
  (defun my:org-clock-return-to-task ()
    "Clock-in to another task that's been worked on today."
    (interactive)
    (let ((clocked-tasks (org-ql-select (org-agenda-files)
                           '(clocked :on today)
                           :action (lambda ()
                                     (propertize (org-get-heading t)
                                                 'marker (copy-marker (point)))))))
      (ivy-read
       "Return to Task: "
       clocked-tasks
       :action
       (lambda (headline)
         (let* ((marker (get-text-property 0 'marker headline))
                (buffer (and (markerp marker) (marker-buffer marker))))
           (when buffer
             (with-current-buffer buffer
               (goto-char marker)
               (org-show-entry)
               (org-clock-in)
               (message (concat "Working on " headline)))))))))
#+END_SRC

*** counsel, ivy & swiper

Make sure Swiper query replace tries to replace all occurrences.

#+BEGIN_SRC emacs-lisp
(defun my:swiper-query-replace-all ()
  (interactive)
  (save-excursion
    (execute-kbd-macro (kbd "M-<")) ;; <- (call-interactively 'ivy-beginning-of-buffer doesn't work?
    (swiper-query-replace)))
#+END_SRC

*** Slime stuff

#+BEGIN_SRC emacs-lisp
(defun my:slime-eval-region-or-sexp ()
    "If region is active, send it. Else, send last sexp."
    (interactive)
    (if (use-region-p)
        (call-interactively 'slime-eval-region)
      (slime-eval-last-expression)))
#+END_SRC

*** Emails

Function to quickly check my emails.

#+BEGIN_SRC emacs-lisp
(defun my:check-emails ()
  (interactive)
  (notmuch-search "date:3M.."))
#+END_SRC
** Aliases

Alias some basic functionality to names that may have different
backends during experimentation.

#+BEGIN_SRC emacs-lisp
  (defalias 'my:find-text               'swiper-isearch)
  (defalias 'my:find-this-text          'swiper-thing-at-point)
  (defalias 'my:find-buffer             'ivy-switch-buffer)
  (defalias 'my:run-program             'counsel-linux-app)
  (defalias 'my:find-file               'counsel-find-file)
  (defalias 'my:terminal-emulator       (if (equal system-type 'windows-nt) 'shell 'vterm))
#+END_SRC

** Keys

#+BEGIN_SRC emacs-lisp
  (general-auto-unbind-keys)

  (defhydra my:music-hydra ()
    "Music Controls"
    ("SPC"      (my:emms-do-then-show 'emms-pause)    "Toggle Play/Pause")
    ("<right>"  (my:emms-do-then-show 'emms-next)     "Next Track")
    ("<left>"   (my:emms-do-then-show 'emms-previous) "Previous Track")
    ("r"        (my:emms-do-then-show 'emms-random)   "Random Track")
    ("m"        (my:emms-do-then-show 'emms)          "Start EMMS")
    ("s"        emms-show                             "Show Current Track")
    ("a"        emms-show-all                         "Show All Track Info")
    ("<escape>" nil                                   "Quit"))

  (general-define-key :keymaps 'emms-playlist-mode-map
    "SPC"      (lambda () (interactive) (my:emms-do-then-show 'emms-pause))
    "<right>"  (lambda () (interactive) (my:emms-do-then-show 'emms-next))
    "<left>"   (lambda () (interactive) (my:emms-do-then-show 'emms-previous))
    "r"        (lambda () (interactive) (my:emms-do-then-show 'emms-random))
    "m"        (lambda () (interactive) (my:emms-do-then-show 'emms))
    "s"        'emms-show
    "a"        'emms-show-all)

  (setq my:shortcut-leader "<f12>")
  (general-define-key :prefix my:shortcut-leader

      ;; Double tap
      my:shortcut-leader 'org-capture

      ;; ? means help
      "?"                'helm-descbinds

      ;; "o"-> Org global shortcuts
      "odd"              'my-org-journal-open-today
      "odt"              'my-org-journal-open-tomorrow
      "ody"              'my-org-journal-open-yesterday
      "oa"               'org-agenda
      "ot"               'org-todo-list
      "oc"               'my:org-concept-open
      "os"               'my:org-search-concept
      "ov"               'my:voice-notes
      "or"               'my:org-refile-transient
      "obii"             'ob-ipython-inspect
      "o SPC"            'my:org-toggle-wrap

      ;; "v"-> VC (Magit) global shortcuts
      "vs"               'magit-status
      "vb"               'magit-blame
      "vd"               'magit-diff

      ;; "m" -> Music
      "m"                'my:music-hydra/body

      ;; "e" -> Email
      "ee"               'my:check-emails
      "es"               'counsel-notmuch

      ;; "l" -> language modes
      "lm"               'markdown-mode
      "lp"               'python-mode
      "le"               'emacs-lisp-mode
      "lc"               'c-mode
      "lo"               'org-mode

      ;; "c" -> Calendar/Clocking
      "cs"               'org-caldav-sync
      "cf"               'cfw:open-org-calendar
      "ci"               'org-clock-in
      "co"               'org-clock-out
      "cq"               'org-clock-cancel
      "cr"               'my:org-clock-return-to-task
      "c SPC"            'my:org-clock-new-task-silent

      ;; "s" -> system
      "sx"                'my:run-program
      "sl"                'counsel-locate
      "sb"                'my:battery-check

      ;; t -> translate
      "t"                 'google-translate-at-point

      ;; "i" -> input methods
      "ie"                (lambda () (interactive) (set-input-method nil) (message "English"))
      "ic"                (lambda () (interactive) (set-input-method 'chinese-tonepy) (message "Chinese (pinyin)"))

      ;; "d" -> debug
      "dbf"                'debug-on-entry
      "dbv"                'debug-on-variable-change
      "dbnf"               'cancel-debug-on-entry
      "dbnv"               'cancel-debug-on-variable-change

      ;; "w" -> window management
      "wb"                 'balance-windows
      "wu"                 'winner-undo
      "wr"                 'winner-redo
      "w RET"              'delete-other-windows
      )

  (general-define-key

      ;; Controlling emacs
      "M-x"        'counsel-M-x
      "<escape>"   'execute-command-toggle
      "S-<escape>" 'execute-command-toggle-ignore-region
      "H-<print>"  'describe-bindings
      "H-<menu>"   'my:toggle-use-frames
      "C-x C-z"    nil ; Was suspend-frame. I've never hit this intentionally
      "C-x C-c"    nil ; Was save-buffers-kill-terminal. Again, I've never done this intentionally.

      ;; Window navigation
      "H-<right>" 'windmove-right
      "H-<left>"  'windmove-left
      "H-<down>"  'windmove-down
      "H-<up>"    'windmove-up
      "<S-f8>"    'delete-window
      "<H-f8>"    'my:kill-current-buffer
      "<f8>"      'delete-window

      ;; Workspaces (virtual desktops/saved window configs/etc)
      "S-<left>"    'tab-bar-switch-to-prev-tab
      "S-<right>"   'tab-bar-switch-to-next-tab
      "S-<up>"      'tab-bar-new-tab
      "C-S-<up>"    'tab-bar-undo-close-tab
      "S-<down>"    'tab-bar-close-tab
      "C-S-<left>"  (lambda () (interactive) (tab-bar-move-tab -1))
      "C-S-<right>" (lambda () (interactive) (tab-bar-move-tab 1))
      "C-S-SPC"     'tab-bar-rename-tab

      ;; Window splitting
      ; names seem wrong, but I imagine dpad right to mean "send focus right", etc.
      "H-s <left>"  'split-window-right
      "H-s <right>" 'split-window-left
      "H-s <down>"  'split-window-above
      "H-s <up>"    'split-window-below

      ; Window resizing
      "H-S-<up>"      'enlarge-window
      "H-S-<right>"   'enlarge-window-horizontally
      "H-S-<down>"    'shrink-window
      "H-S-<left>"    'shrink-window-horizontally

      ;; Frame manipulations
      "<H-f11>"   'toggle-frame-fullscreen
      "H-t"       'my:set-window-opacity

      ;; Keyboard macros
      "H-*"        'kmacro-start-macro
      "<f1>"       (lambda () (interactive) (my:run-or-save-macro "f1"))
      "<f2>"       (lambda () (interactive) (my:run-or-save-macro "f2"))
      "<f3>"       (lambda () (interactive) (my:run-or-save-macro "f3"))
      "<f4>"       (lambda () (interactive) (my:run-or-save-macro "f4"))
      "C-<f1>"     (lambda () (interactive) (my:run-macro "f1"))
      "C-<f2>"     (lambda () (interactive) (my:run-macro "f2"))
      "C-<f3>"     (lambda () (interactive) (my:run-macro "f3"))
      "C-<f4>"     (lambda () (interactive) (my:run-macro "f4"))

      ;; File operations
      "<f5>"   'my:find-file
      "<f6>"   'save-buffer
      "<f7>"   'my:save-as
      "H-<f5>" 'my:revert-buffer-no-prompt

      ;; OS Utilities
      "H-f"  'counsel-ag
      "H-F"  (lambda () (interactive) (setq current-prefix-arg '(4))(call-interactively 'counsel-ag))
      "<f9>" 'my:terminal-emulator

      ;; Text navigation
      "<home>"   'smart-beginning-of-line
      "M-<up>"   'backward-paragraph
      "M-<down>" 'forward-paragraph
      "H-a"      'my:find-text
      "H-A"      'my:find-this-text
      "H-M-a"    'my:find-this-text
      "H-["      'my:goto-previous-change
      "H-]"      'my:goto-next-change
      "H-g"      'my:goto-line
      "H-p"      'isearch-forward-regexp

      ;; Text selection and editing
      "C-<delete>"   'smart-batch-delete
      "<insert>"     'smart-copy-paste
      "<delete>"     'smart-cut-or-delete
      "C-SPC"        'smart-set-mark
      "H-r"          'anzu-query-replace-regexp
      "H-y"          'yas-insert-snippet
      "H-u"          'counsel-unicode-char
      "H-i"          'emojify-insert-emoji
      "C-<return>"   'newline-after-current
      "M-<return>"   'newline-before-current
      "C-M-<return>" 'newline-before-and-after-current
      "C-t"          'indent-according-to-mode
      "C-z"          'undo-tree-undo
      "C-S-z"        'undo-tree-redo
      "H-z"          'undo-tree-visualize
      "C-c a"        'mark-whole-buffer
      "M-Q"          'unfill-paragraph
      "H-q"          'iedit-mode

      ;; Bookmarks
      "H-SPC"                   'bm-toggle
      "H-S-SPC"                 'my:annotated-bookmark
      "H-}"                     'bm-next
      "H-{"                     'bm-previous
      "<left-margin> <mouse-1>" 'bm-toggle-mouse

      ;; Buffer navigation
      "H-b"         'my:find-buffer
      "H-B"         'counsel-locate
      "<prior>"     'previous-appropriate-buffer
      "<next>"      'next-appropriate-buffer
      "C-H-<left>"  'buf-move-left
      "C-H-<right>" 'buf-move-right
      "C-H-<up>"    'buf-move-up
      "C-H-<down>"  'buf-move-down
      "C-<up>"      'my:scroll-down-some-lines
      "C-<down>"    'my:scroll-up-some-lines
      "C-<left>"    'my:scroll-left-some-lines
      "C-<right>"   'my:scroll-right-some-lines

      ;; screen recording and screenshots
      "M-<print>"   'camcorder-mode

      ;; Quick access to toggle play/pause
      "<pause>"          (lambda () (interactive) (my:emms-do-then-show 'emms-pause))

      ;; hide/show blocks
      "H-/" 'origami-toggle-node

      ;; Other
      "H-=" '(lambda () (interactive) (text-scale-increase 1))
      "H--" '(lambda () (interactive) (text-scale-decrease 1))

      ;; Auto Yasnippet
      "H-W" 'aya-create
      "H-w" 'aya-expand)

  (general-define-key :keymaps 'isearch-mode-map
      "<backspace>" 'isearch-del-char
      "<escape>"    'isearch-exit
      "<C-escape>"  'isearch-abort
      "<return>"    'isearch-repeat-forward
      "S-<return>"  'isearch-repeat-backward
      "<right>"     'isearch-yank-word-or-char
      "<left>"      'isearch-del-char
      "<down>"      'isearch-repeat-forward
      "<up>"        'isearch-repeat-backward)

  (general-define-key :keymaps 'ivy-minibuffer-map
      "S-<return>" 'ivy-immediate-done)

  (general-define-key :keymaps 'camcorder-moode-map
      "M-<print>" 'camcorder-stop)

  (general-define-key :keymaps '(query-replace-map multi-query-replace-map)
      "<up>"     'backup
      "<down>"   'skip
      "<escape>" 'exit
      "<return>" 'act
      "<insert>" 'edit)

  (general-define-key :keymaps 'slime-mode-map
      "C-\\" 'my:slime-eval-region-or-sexp
      "H-h"  (lambda () (interactive) (call-interactively 'slime-documentation))
      "TAB"  (gen-smart-tab-key 'indent-for-tab-command 'auto-complete 2)
      "H-h" 'common-lisp-hyperspec)

  (general-define-key :keymaps 'nov-mode-map
      "<home>" nil
      "<end>"  nil)

  (general-define-key :keymaps 'swiper-map
      "H-r"    'my:swiper-query-replace-all)

  (general-define-key :keymaps 'c-mode-map
      "<tab>" 'c-smart-tab-key
      "TAB"   'c-smart-tab-key
      "C-t"   'c-indent-line-or-region
      "C-r"   'align-current)

  (general-define-key :keymaps 'emacs-lisp-mode-map
      "C-\\" 'eval-region)

  (general-define-key :keymaps 'emmet-mode-keymap
      "TAB" 'emmet-expand-yas) ;; my tab key management is getting out of hand & I need to do something about it.

  (general-define-key :keymaps 'c-mode-map :prefix "H-c"
      "1" 'c-insert-region-heading
      "2" 'c-insert-function-skeleton
      "3" 'c-insert-forced-todo
      "4" 'c-insert-debugging-printf
      "5" 'c-insert-ternary-for-boolean-to-string
      "6" 'c-insert-todo-comment
      "f" 'c-insert-if-block
      "o" 'c-insert-for-block
      "w" 'c-insert-while-block
      "d" 'c-insert-do-while-block
      "F" 'c-insert-preproc-if-block
      "D" 'c-insert-preproc-ifdef-block
      "N" 'c-insert-preproc-ifndef-block
      "I" 'c-insert-preproc-include-block)

  (general-define-key :keymaps 'python-mode-map
      "H-/"     'counsel-jedi
      "C-c C-c" 'python-shell-send-block)

  (general-define-key :keymaps 'prog-mode-map
      "H-;"   'my:comment-region-or-line
      "H-:"   'my:comment-region-or-line-keep-clone
      "H-e o" 'poporg-dwim
      "H-e s" 'my:edit-as-source)

  (general-define-key :keymaps 'auto-highlight-symbol-mode-map
      "s-<up>"   'ahs-backward
      "s-<down>" 'ahs-forward)

  (general-define-key :keymaps 'org-agenda-mode-map
      "p"           'org-agenda-priority
      "t"           'my:org-agenda-todo-and-redo
      "T"           'org-todo-yesterday
      "s"           'org-agenda-schedule
      "M-<up>"      'backward-paragraph
      "M-<down>"    'forward-paragraph
      "<RET>"       'my:org-agenda-switch-to)

  (general-define-key :keymaps 'shell-mode-map
      "C-p"   'comint-previous-input
      "C-n"   'comint-next-input
      "C-M-l" nil)

  (general-define-key :keymaps 'flyspell-mode-map
      "H-c" 'flyspell-auto-correct-word)

  (general-define-key :keymaps 'pdf-view-mode-map
      "H-a" 'isearch-forward) ;; pdf-tools has specific support for this search method

  (general-define-key :keymaps '(org-mode-map org-agenda-mode-map)
      "S-<left>"    'tab-bar-switch-to-prev-tab ;; take this back
      "S-<right>"   'tab-bar-switch-to-next-tab
      "S-<up>"      'tab-bar-new-tab
      "C-S-<up>"    'tab-bar-undo-close-tab
      "S-<down>"    'tab-bar-close-tab
      "C-S-<left>"  (lambda () (interactive) (tab-bar-move-tab -1))
      "C-S-<right>" (lambda () (interactive) (tab-bar-move-tab 1))
      "C-S-SPC"     'tab-bar-rename-tab
      "C-c C-t"     'my:org-todo
      "H-|"         (lambda () (interactive) (save-buffer) (org-latex-export-to-pdf))
      "H-x"         'org-babel-execute-buffer
      "H-."         (lambda () (interactive) (progn
                                       (org-insert-time-stamp nil t t)
                                       (newline)))
      "<H-M-return>" 'org-babel-demarcate-block
      "<print>"      'ros)

  (general-define-key :keymaps 'dired-mode-map
      "o" 'dired-omit-mode
      "p" (lambda () (interactive) (emms-play-dired) (my:voice-note-make-timestamp)))

  (general-define-key :keymaps 'notmuch-show-mode-map
      "v" (lambda () (interactive) (call-process
                                     "thunderbird" nil nil nil
                                     (notmuch-show-get-filename))))

  (customize-set-variable 'exwm-input-global-keys
      `((,(kbd "H-<left>") .    windmove-left)
        (,(kbd "H-s <up>") .    split-window-below)
        (,(kbd "H-<right>") .   windmove-right)
        (,(kbd "H-<down>") .    windmove-down)
        (,(kbd "H-<up>") .      windmove-up)
        (,(kbd "<H-f8>") .      my:kill-current-buffer)
        (,(kbd "S-<F8>") .      delete-window)
        (,(kbd "S-<F8>") .      delete-window)
        (,(kbd "H-b") .         my:find-buffer)
        (,(kbd "H-S-<up>") .    (lambda () (interactive) (enlarge-window ,(if (e27-p) 1 5)))) ;; Emacs 27 is fast at this
        (,(kbd "H-S-<right>") . enlarge-window-horizontally)
        (,(kbd "H-S-<down>") .  (lambda () (interactive) (shrink-window ,(if (e27-p) 1 5)))) ;; Emacs 27 is fast at this
        (,(kbd "H-S-<left>") .  shrink-window-horizontally)
        (,(kbd "H-s <down>") .  split-window-above)
        (,(kbd "H-s <left>") .  split-window-right)
        (,(kbd "H-s <right>") . split-window-left)
        (,(kbd "H-c") .         exwm-input-release-keyboard)
        (,(kbd "H-l") .         exwm-input-grab-keyboard)
        (,(kbd "H-e") .         exwm-edit--compose)))

  (customize-set-variable 'exwm-input-simulation-keys
      `((,(kbd "H-a") .        ,(kbd "C-f"))
        (,(kbd "<insert>") .   ,(kbd "C-c"))
        (,(kbd "S-<insert>") . ,(kbd "C-v"))))
#+END_SRC

Org agenda keymap modifications. Changing the keymap itself doesn't
seem to work.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-agenda-mode-hook
    (lambda ()
      (local-set-key (kbd "b")
        (lambda ()
          (interactive)
          (if (eq org-agenda-dim-blocked-tasks 't)
              (setq org-agenda-dim-blocked-tasks 'invisible)
            (setq org-agenda-dim-blocked-tasks 't))
          (org-agenda-redo 't)))))
#+END_SRC

Clear out some keys from the vterm-map that I just never actually need in the terminal.

#+BEGIN_SRC emacs-lisp
  (mapcar (lambda (key)
            (define-key vterm-mode-map (kbd key) nil))
          '("<f1>" "<f2>" "<f3>" "<f4>" "<f5>" "<f6>"
            "<f7>" "<f8>" "<f9>" "<f10>" "<f11>" "<f12>"))
#+END_SRC

* Utility

This section defines general purpose code snippets, which are used
throughout the rest of the file.

** Navigation and environment macros.

#+BEGIN_SRC emacs-lisp
(defmacro my:recenter-on-jump (&rest body)
  "If, during the evaulation of body, point moves past the window's limits,
   in either direction, recenter the buffer in the window."
  `(let*
       ((last-pt (window-end))
        (first-pt (window-start)))
     ,@body
     (when (or (> (point) last-pt) (< (point) first-pt))
            (recenter))))

(defmacro my:retain-position-from-symbol-start (&rest body)
  "Any change of point in this macro body will be readjusted to retain
   the starting distance from the beginning of the current symbol. Most
   reasonable use is when jumping between occurrences of the same symbol."
  `(let*
       ((pos (point))
        (offset (save-excursion
                  (when (not (looking-at "\\_<"))
                    (search-backward-regexp "\\_<"))
                  (- pos (point)))))
     ,@body
     (when (not (looking-at "\\_<"))
       (search-backward-regexp "\\_<"))
     (right-char offset)))

(defmacro my:do-with-silent-bell (&rest body)
  "Evaluate body with the system bell silenced. Note that any changes
   to ring-bell-function during body will be lost."
  `(let
       ((ring-bell-function-backup ring-bell-function))
     (setq ring-bell-function nil)
     ,@body
     (setq ring-bell-function ring-bell-function-backup)))
#+END_SRC

General functions.

#+BEGIN_SRC emacs-lisp
  (defun match-strings-all (&optional string)
    "Return the list of all expressions matched in last search.
  STRING is optionally what was given to `string-match'.
  From https://www.emacswiki.org/emacs/ElispCookbook#toc36"
    (let ((n-matches (1- (/ (length (match-data)) 2))))
      (mapcar (lambda (i) (match-string i string))
              (number-sequence 0 n-matches))))

(defun my:kill-current-buffer ()
  "kill the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))

(defun my:keyboard-escape-quit ()
  "Just silence the bell"
  (interactive)
  (my:do-with-silent-bell
   (keyboard-escape-quit)))

(defun my:line-word-char-count (&optional start end)
   "Returns formatted string with number of lines, words
    and characters in region or whole buffer."
   (interactive)
   (let ((n 0)
         (start (if mark-active (region-beginning) (point-min)))
         (end (if mark-active (region-end) (point-max))))
     (save-excursion
       (goto-char start)
       (while (< (point) end) (if (forward-word 1) (setq n (1+ n)))))
     (format "[ L%d W%d C%d ] " (count-lines start end) n (- end start))))

(defun my:line-to-top-of-window ()
   "Shift current line to the top of the window-  i.e. zt in Vim"
   (interactive)
   (set-window-start (selected-window) (point)))

(defun my:purge-buffers ()
  "Kill all buffers which aren't being shown."
  (interactive)
  (mapcar 'kill-buffer (remove-if '(lambda (x) (with-current-buffer x (get-buffer-window))) (buffer-list))))

(defun my:set-window-opacity (percent)
  "Set window opacity. Prefix arg is opacity in percent."
  (interactive "p")
  (set-frame-parameter (selected-frame) 'alpha percent))
#+END_SRC

** Windows

Set window size from elisp.

#+BEGIN_SRC emacs-lisp
(defun set-window-width (cols)
  "Set the selected window's width."
  (window-resize (selected-window) (- cols (window-width)) t))

(defun set-window-height (rows)
  "Set the selected window's height."
  (window-resize (selected-window) (- rows (window-height))))
#+END_SRC

** Minor Modes

*** Sticky Buffer Mode

Marries a buffer to a window.

#+BEGIN_SRC emacs-lisp
(define-minor-mode sticky-buffer-mode
  "Make the current window always display this buffer."
  nil " sticky" nil
  (set-window-dedicated-p (selected-window) sticky-buffer-mode))
#+END_SRC

** Buffer Monitoring

This is a purely TODO item. Previous version had some code to monitor
a buffer and alert upon new appearances of a particular regex.

** Package Extensions

Preload swiper with thing at point.

#+BEGIN_SRC emacs-lisp
;; https://github.com/abo-abo/swiper/issues/1068
(defun ivy-with-thing-at-point (cmd)
  (let ((ivy-initial-inputs-alist
         (list
          (cons cmd (thing-at-point 'symbol)))))
    (funcall cmd)))

;; Example 2
(defun swiper-thing-at-point ()
  (interactive)
  (ivy-with-thing-at-point 'swiper))
#+END_SRC

** Seafile

Working with Seafile conflicts.

#+BEGIN_SRC emacs-lisp
  (defvar my:seafile-conflict-fname-regex "\\(.*\\) (SFConflict \\([^[:space:]]+\\) \\([^[:space:]]+\\))\\(.*\\)")

  (defun my:delete-current-file-kill-buffer ()
    "Delete file associated with current buffer, then kill the buffer"
    (interactive)
    (let
        ((file (buffer-file-name)))
      (if (not file)
          (error "No file associated with buffer!")
        (if (yes-or-no-p (concat "Delete file? "))
           (progn
             (delete-file file)
             (kill-buffer))))))

  (defun my:fname-seafile-conflict-p (filename)
    "Is this filename a Seafile conflict file?
     Return fnamepart, user, date, and extension if so.
     'somefilename (SFConflict me@somewhere.com 1900-02-12).org' -> '(somefilename me@somewhere.com 1900-02-12 .org"
    (if (string-match my:seafile-conflict-fname-regex filename)
      (rest (match-strings-all filename))))

  (defun my:seafile-conflict-source-fname (filename)
    "Return the path to the original file from which this conflict was created."
    (let*
        ((parts (my:fname-seafile-conflict-p filename))
         (fname (and parts (nth 0 parts)))
         (ext   (and parts (nth 3 parts))))
      (concat fname ext)))

  (defun my:seafile-list-conflicting-files (path)
    "Search a path recursively for Seafile conflict files, and return any hits."
    (directory-files-recursively path my:seafile-conflict-fname-regex))

  (defun my:delete-conflict-file (conflict-file &optional prompt)
    "Delete a conflict file -- optionally prompt the user."
    (if (or (not prompt) (yes-or-no-p (concat "Source file deleted for \"" conflict-file "\", delete conflict file? ")))
        (delete-file conflict-file)))

  (defun my:merge-seafile-conflict (source conflict &optional prompt)
    "For now, just opens both."
    (if (or (not prompt) (y-or-n-p (concat "Merge conflict for \"" source "\"? ")))
        (progn
          (find-file source)
          (split-window-left)
          (find-file conflict))))

  (defun my:seafile-merge-conflicts (path)
    "Interactively merge conflicting files in a given path."
    (interactive "DDirectory:")
    (let*
        ((conflict-file (completing-read "Choose conflict to merge: " (my:seafile-list-conflicting-files path)))
         (source-file (my:seafile-conflict-source-fname conflict-file)))
      (if (and (file-exists-p conflict-file)
               (file-exists-p source-file))
          (my:merge-seafile-conflict source-file conflict-file)
        (my:delete-conflict-file conflict-file t))))

  (defun my:org-merge-conflict ()
    "Interactively merge "
    (interactive)
    (my:seafile-merge-conflicts my:org-file-tree-base-path))
#+END_SRC

** Screenshots

[[https://github.com/LionyxML/ros/blob/master/ros.el][ros]] from LionxyML.

#+BEGIN_SRC emacs-lisp
(defun ros ()
  (interactive)
  (let ((filename
    (concat "./"
      (file-name-nondirectory buffer-file-name)
      "_"
      (format-time-string "%Y%m%d_%H%M%S")
      ".png")))
  (call-process "scrot" nil nil nil "-s" filename)
  (when (file-exists-p filename)
    (insert (concat "#+ATTR_ORG: :width 400\n[[" filename "]]")))
  (org-display-inline-images t t)))
#+END_SRC

** Drawings

Looks for org-mode link at point, attempts to open it in KolourPaint,
then refreshes images after exiting.

#+BEGIN_SRC emacs-lisp
(defun my:org-edit-sketch (sketch-name)
  (start-process "sketch-process" nil "kolourpaint" (concat (file-name-directory (buffer-file-name)) "sketch-" sketch-name ".png")))

(org-link-set-parameters "sketch" :follow 'my:org-edit-sketch)
#+END_SRC

** Voice Notes

*** Automated Transcription

Run =voicenotes2org=, and open my unfiled voice notes file.

#+BEGIN_SRC emacs-lisp
(defun my:file-voice-notes ()
  "Kick off transcription of any new voice-notes, and open the unfiled notes file."
  (interactive)
  (async-shell-command "voicenotes2org")
  (find-file "/sync/documents/org/voice-notes/unfiled-notes.org"))
#+END_SRC

*** Manual Transcription

Small function that creates and shows a new EMMS buffer with tracks
from my voice notes directory (synced from my phone).

#+BEGIN_SRC emacs-lisp
(defun my:voice-notes ()
  "Open voice notes in EMMS buffer for processing."
  (interactive)
  (split-window-below)
  (emms-play-directory "/sync/voice-notes")
  (emms)
  (emms-playlist-sort-by-file-mtime))
#+END_SRC

This function, when called from a dired buffer, attempts to check the
filename under point against my voice note naming regex. If it
matches, then it creates an inactive timestamp that corresponds to the
filename and pushes that onto the kill-ring. I use this for
transcribing and categorizing voice notes.

#+BEGIN_SRC emacs-lisp
(defun my:voice-note-make-timestamp ()
  "In dired buffer, with point over a voice note, create an org timestamp and push it onto the kill-ring."
  (interactive)
  (let ((fname (dired-get-filename)))
    (when (string-match ".*My recording \\([[:digit:]]+\\)-\\([[:digit:]]+\\)-\\([[:digit:]]+\\) \\([[:digit:]]+\\)-\\([[:digit:]]+\\) \\(..\\).*\\.wav" fname)
      (let*
        ((year           (match-string 1 fname))
         (month          (match-string 2 fname))
         (day            (match-string 3 fname))
         (hour           (match-string 4 fname))
         (minute         (match-string 5 fname))
         (ampm           (match-string 6 fname))
         (hour           (if (string= ampm "PM") (number-to-string (+ 12 (string-to-number hour))) hour))
         (normed-timestr (concat year "-" month "-" day " " hour ":" minute))
         (time           (apply 'encode-time (parse-time-string normed-timestr))))
      (kill-new (format-time-string "[%Y-%m-%d %a %H:%M]" time))
      (message "Timestamp pushed onto kill-ring.")))))
#+END_SRC

** Webpage Archives

Add an org-link type that opens a webpage archive in Firefox. Also,
add a function which downloads the webpage and all dependencies using
wget.

#+BEGIN_SRC emacs-lisp
(defun my:org-slurp-webpage ()
  (interactive)
  (let*
      ((shortname   (read-string "Name for Archived Page:"))
       (url         (read-string "URL to Archive:"))
       (cachefname  (concat (file-name-directory (buffer-file-name)) "cache-" shortname))
       (linktarget (concat "./cache-" shortname "/" url)))
    (start-process "slurp-process" nil "wget" "--page-requisites"
                                              "--convert-links"
                                              "--no-parent"
                                              "--html-extension"
                                              "--directory-prefix" cachefname
                                              url)
    (insert (concat "[[pagecache:" linktarget "][" shortname "]]"))))

(defun my:org-open-slurped-webpage (name)
  (start-process "firefox-process" nil "firefox" (concat name)))

(org-link-set-parameters "pagecache" :follow 'my:org-open-slurped-webpage)
#+END_SRC

** Battery

Get battery life

#+BEGIN_SRC emacs-lisp
(defun my:battery-percent ()
  (string-to-number (battery-format "%p" (funcall battery-status-function))))

(defun my:battery-percent ()
  100)

(defun my:battery-message ()
  (battery-format " %t (%p%%%%) " (funcall battery-status-function)))

(defun my:battery-check ()
  "Echo battery level."
  (interactive)
  (message (my:battery-message)))
#+END_SRC

** Microsoft Windows

Open a CMD shell buffer on WSL.

#+BEGIN_SRC emacs-lisp
(defun my:open-cmd-shell-buffer ()
  (interactive)
  (process-send-string (get-buffer-process "*shell*") "cmd.exe"))
#+END_SRC

From within =WSL=, call =waf= on a product name using MSYS2 =bash= as
packaged by the Window =Git= distribution.

It's shell hell folks.

#+BEGIN_SRC emacs-lisp
(defun my:wsl-waf ()
  (interactive)
  (let ((shell-file-name "/c/Program Files/Git/bin/bash.exe"))
    (compile (concat "./waf " (read-string "Product Name: ")))))
#+END_SRC

** Other Stuff

Copy current buffer's path to clipboard. Taken from [[https://stackoverflow.com/questions/2416655/file-path-to-clipboard-in-emacs][StackOverflow]].

#+BEGIN_SRC emacs-lisp
(defun my:copy-buffer-filename-as-kill ()
  "Put the current file name on the clipboard"
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (with-temp-buffer
        (insert filename)
        (clipboard-kill-region (point-min) (point-max)))
      (message filename))))
#+END_SRC

Gather number at point, interpret it as seconds since Unix epoch, and echo the formatted datetime.

#+BEGIN_SRC emacs-lisp
(defun my:echo-datetime-at-point ()
  "Message integer at point as a Unix timestamp."
  (interactive)
  (message (concat
      (format-time-string "%D %T Local" (seconds-to-time (thing-at-point 'number)) nil)
      (format-time-string " (%D %T UTC)" (seconds-to-time (thing-at-point 'number)) t))))
#+END_SRC

Insert current time as unix epoch.

#+BEGIN_SRC emacs-lisp
(defun my:insert-epoch-time ()
  "Insert current seconds since epoch at point."
  (interactive)
  (insert (number-to-string (time-to-seconds))))
#+END_SRC

** Debugging & Maintaining Emacs

Emacs defines commands both ='toggle-debug-on-error= and ='toggle-debug-on-quit=, but debugging on a specific message is only supported by a variable. Add ='toggle-debug-on-message=, which clears the current trigger message if it is set, and otherwise, prompts the user to enter a regex.

#+BEGIN_SRC emacs-lisp
(defun toggle-debug-on-message (regex)
  "Set a message to debug on, or clear it."
  (interactive "sRegex Trigger: ")
  (if debug-on-message
      (setq debug-on-message nil)
    (setq debug-on-message regex)))
#+END_SRC

Quickly clear out byte-compiled elisp files.

#+BEGIN_SRC emacs-lisp
(defun my:clear-byte-compiled-init-files ()
  "Clean up *.elc files in init dir."
  (interactive)
  (shell-command-to-string "find ~/.emacs.d/ -name \"*.elc\" -type f | xargs rm -f"))
#+END_SRC

* User Interface Settings

This section defines code which modifies how emacs displays buffers
and interacts with the user.

** Tweaks

Make sure emacsclient doesn't open in the background.

#+BEGIN_SRC emacs-lisp
(add-hook 'server-switch-hook
  (lambda ()
    (raise-frame)
    (select-frame-set-input-focus (selected-frame))))
#+END_SRC

Allow file management in counsel's file-find

#+BEGIN_SRC emacs-lisp
;; https://github.com/abo-abo/swiper/wiki/Copy,-move-and-delete-file-actions-for-counsel-find-file
(defun reloading (cmd)
    (lambda (x)
      (funcall cmd x)
      (ivy--reset-state ivy-last)))
  (defun given-file (cmd prompt) ; needs lexical-binding
    (lambda (source)
      (let ((target
      (let ((enable-recursive-minibuffers t))
      (read-file-name
      (format "%s %s to:" prompt source)))))
      (funcall cmd source target 1))))
(defun confirm-delete-file (x)
    (dired-delete-file x 'confirm-each-subdirectory))

  (ivy-add-actions
   'counsel-find-file
   `(("c" ,(given-file #'copy-file "Copy") "copy")
     ("d" ,(reloading #'confirm-delete-file) "delete")
     ("m" ,(reloading (given-file #'rename-file "Move")) "move")))
  (ivy-add-actions
   'counsel-projectile-find-file
   `(("c" ,(given-file #'copy-file "Copy") "copy")
     ("d" ,(reloading #'confirm-delete-file) "delete")
     ("m" ,(reloading (given-file #'rename-file "Move")) "move")
     ("b" counsel-find-file-cd-bookmark-action "cd bookmark")))
#+END_SRC

Show current/total matches in isearch

#+BEGIN_SRC emacs-lisp
(global-anzu-mode +1)
#+END_SRC

Show whitespace

#+BEGIN_SRC emacs-lisp
(global-whitespace-mode 0)
(setq whitespace-style '(face trailing))
#+END_SRC

Use visual bell instead of audible, modified from code by Miles Bader. Code
mirror on GitHub [[https://github.com/tobias/emacs.d/blob/master/lib/echo-area-bell.el][here]].

#+BEGIN_SRC emacs-lisp
  (defun echo-area-flash (color &optional duration message)
    "Flash a colorful message in the echo area."
    (setq duration (or duration 0.1))
    (setq message (or message ""))
    (unless (memq this-command '(keyboard-quit keyboard-escape-quit))
      (message (propertize
               (concat
                (propertize
                 "x"
                 'display
                 `(space :align-to (- right ,(+ 2 (length message)))))
                message)
               'face `(:background ,color :foreground "white" :weight bold)))
      (sit-for duration)
      (message "")))

  (defun echo-area-bell ()
    "Flash the some color in the echo area."
    (echo-area-flash "red" nil "*DING* "))

  (defun ding ()
    (echo-area-flash "hotpink"))

  (setq ring-bell-function 'echo-area-bell)
#+END_SRC

Get rid of blinking cursor

#+BEGIN_SRC emacs-lisp
(setq default-cursor-type 'box)
(blink-cursor-mode -1)
#+END_SRC

Display trailing whitespace

#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
#+END_SRC

Highlight body of parens

#+BEGIN_SRC emacs-lisp
(setq show-paren-style 'expression)
(show-paren-mode 1)
#+END_SRC

Use a consistent window name. This helps with AutoHotkey recognition on Windows, in addition to being a little more usable in Linux.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format (if (equal system-type 'windows-nt) "emacs-nt" "emacs"))
#+END_SRC

Make sure we push any kill-ring data into OS clipboard.

#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

Highlight the current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

When buffer is not modified in emacs, automatically reload it when its file changes on disk. Also allow dired, etc, to autorevert.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
(customize-set-variable 'global-auto-revert-non-file-buffers t)
#+END_SRC

Tweak the text shown when hiding regions of a buffer.

#+BEGIN_SRC emacs-lisp
(setq hide-region-before-string "hidden-region-->")
(setq hide-region-after-string "<--hidden-region")
#+END_SRC

Make sure that diff-hl-mode is showing changes between now and the last commit, only.

#+BEGIN_SRC emacs-lisp
(global-diff-hl-amend-mode 1)
#+END_SRC

Fall back to frame-moving if window-moving doesn't cut it.

#+BEGIN_SRC emacs-lisp
(setq framemove-hook-into-windmove t)
#+END_SRC

Remove flashy splash stuff

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(setq inhibit-startup-echo-area-message t)
(setq inhibit-startup-screen t)
(setq inhibit-startup-message t)
#+END_SRC

Show prefix keys in the echo area much faster.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.001)
#+END_SRC

Indicate tabs.

#+BEGIN_SRC emacs-lisp
(standard-display-ascii ?\t "→   ")
#+END_SRC

And never insert tabs.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'indent-tabs-mode nil)
#+END_SRC

Highlight some common tags.

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'prog-mode
  '(("\\<\\(DEBUG\\)" 1 font-lock-warning-face prepend)
    ("\\<\\(FIXME\\)" 1 font-lock-warning-face prepend)
    ("\\<\\(TODO\\)"  1 font-lock-warning-face prepend)
    ("\\<\\(JIRA\\)"  1 font-lock-warning-face prepend)))
#+END_SRC

Clear the minibuffer.

#+BEGIN_SRC emacs-lisp
(delete-minibuffer-contents)
#+END_SRC

Move the cursor to corner of display.

#+BEGIN_SRC emacs-lisp
(mouse-avoidance-mode 'banish)
#+END_SRC

When deleting the last window in a frame, delete the frame (rather
than failing to delete the window).

#+BEGIN_SRC emacs-lisp
(defadvice delete-window (around delete-frame-if-one-win activate)
  "If WINDOW is the only one in its frame, then `delete-frame' too.
   Source: https://www.emacswiki.org/emacs/download/frame-cmds.el"
  (with-selected-window
    (or (ad-get-arg 0)  (selected-window))
    (if (one-window-p t)
        (if (and (boundp 'tab-bar-mode) tab-bar-mode)
            (tab-bar-close-tab)
          (delete-frame))
      ad-do-it)))
#+END_SRC

Give visual feedback on tab creation/close.

#+BEGIN_SRC emacs-lisp
(add-hook 'tab-bar-tab-pre-close-functions
  (lambda (idx last-tab)
    (ding)))

(add-hook 'tab-bar-tab-post-open-functions
  (lambda (tab)
    (ding)))
#+END_SRC

Use icons in Ovy (switch buffer, etc)

#+BEGIN_SRC emacs-lisp
(all-the-icons-ivy-setup)
#+END_SRC

Tell Olivetti to use a sane default width.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
  '(olivetti-body-width 130)
  '(olivetti-minimum-body-width 130))
#+END_SRC

Always open shell buffers in the current window.

#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist
             '("^\\*shell\\*$" . (display-buffer-same-window)))
#+END_SRC

Run with scissors.

#+begin_src emacs-lisp
(setq disabled-command-function nil)
#+end_src

** posframe

Use ivy-posframe by default, exempt swiper. Based on [[https://github.com/tumashu/ivy-posframe][the documentation]].

#+BEGIN_SRC emacs-lisp
(setq ivy-posframe-display-functions-alist
        '((swiper-isearch . nil)
          (t . ivy-posframe-display-at-frame-center)))

(setq ivy-posframe-height-alist '((swiper-isearch . 15) (t . 35))
      ivy-posframe-parameters   '((internal-border-width . 1)
                                  (left-fringe . 8)
                                  (right-fringe . 8)
                                  (alpha . 70 )))

(setq ivy-posframe-width 130)

(ivy-posframe-mode 1)
#+END_SRC

** Mode Line & Header Line

This code adds a strongly customized header and mode line.

TODO: Serious cleanup and reorg needed. Works well, but the code is
nasty.

#+BEGIN_SRC emacs-lisp
(defface my-header-line-face                   nil "Face of header line.")
(defface my-header-line-inactive-face          nil "Face of header line (inactive).")
(defface mode-line-buffer-name-face            nil "Face of buffer name in mode line.")
(defface mode-line-buffer-name-inactive-face   nil "Face of buffer name in mode line (inactive).")
(defface mode-line-notification-face           nil "Face of mode line notifications.")
(defface mode-line-notification-inactive-face  nil "Face of mode line notifications (inactive).")

(customize-set-variable 'mode-line-in-non-selected-windows nil)

(defmacro my-header-line ()
  `(list
      '(:eval
        (let*
            ((mface (if (window-has-focus)
                        'my-header-line-face
                      'my-header-line-inactive-face)))
          (propertize
           (concat
            " "
            (if (buffer-file-name)
                (buffer-file-name)
              (buffer-name))
            (mode-line-fill mface (if (window-has-focus)
                                      0;34
                                    0)))
           'face mface)))))

(setq-default header-line-format (my-header-line))
(setq header-line-format (my-header-line))


(defvar my-selected-window nil)
(add-hook 'post-command-hook
          (lambda ()
            ;; (when (not (minibuffer-selected-window))
              (setq my-selected-window (selected-window))))

(defun window-has-focus ()
  (eq
   (selected-window)
   my-selected-window))

(defun debug-window-focus ()
  (interactive)
  (format "%s & %s & %s & %s & %s" mode-line-frame-identification (frame-selected-window) (get-buffer-window) (selected-frame) (window-frame (get-buffer-window))))

(defmacro mode-line-notification-entry (check text help-echo)
  `'(:eval (when ,check
             (let*
                 ((mface (if (window-has-focus)
                             'mode-line-notification-face
                           'mode-line-notification-inactive-face))
                  (bface (if (window-has-focus)
                             'my-header-line-face
                           'my-header-line-inactive-face)))
               (concat
                (propertize ,text
                           'face mface
                           'help-echo ,help-echo)
                (propertize " "
                            'face bface))))))

(defmacro mode-line-status-entry (check text help-echo)
  `'(:eval (when ,check
             (let*
                  ((mface (if (window-has-focus)
                              'mode-line-buffer-name-face
                            'mode-line-buffer-name-inactive-face))
                   (bface (if (window-has-focus)
                             'my-header-line-face
                           'my-header-line-inactive-face)))
             (concat
                (propertize ,text
                            'face mface
                            'help-echo ,help-echo)
                (propertize " "
                            'face bface))))))

(defmacro mode-line-buffer-name-entry (format-str help-echo)
  `'(:eval
     (let*
         ((mface (if (window-has-focus)
                     'mode-line-buffer-name-face
                   'mode-line-buffer-name-inactive-face)))
        (propertize ,format-str
                    'face mface
                    'help-echo ,help-echo))))

(defmacro mode-line-str-dflt (body)
  `'(:eval
      (let*
         ((mface (if (window-has-focus)
                     'my-header-line-face
                   'my-header-line-inactive-face)))
       (propertize
        ,body
        'face mface))))

(defun mode-line-fill (face reserve)
  "Return empty space using FACE and leaving RESERVE space on the right."
  (unless reserve
    (setq reserve 20))
  (when (and window-system (eq 'right (get-scroll-bar-mode)))
    (setq reserve (- reserve 3)))
  (propertize " "
              'display `((space :align-to (- (+ right right-fringe right-margin) ,reserve)))
              'face face))

(setq-default mode-line-format
  (list
    ; buffer name field
    '(:eval
      (let*
          ((mface  (if (window-has-focus)
                              'mode-line-buffer-name-face
                            'mode-line-buffer-name-inactive-face)))
        (propertize " %b " 'face mface)))

    ; buffer position field
    (mode-line-str-dflt " %p (%l,%c) ")

    ; major mode field
    (mode-line-buffer-name-entry " %m " buffer-file-coding-system)

    (mode-line-str-dflt " ")

    ;;; MODE SPECIFIC AREAS

    ; text mode: Show word, letter, char count
    '(:eval (when (eq major-mode 'text-mode)
             (mode-line-str-dflt
              (if transient-mark-mode
               (my:line-word-char-count (point) (mark))
               (my:line-word-char-count)))))

    ;;; STATUSES: less important stuff
    (mode-line-status-entry (/= text-scale-mode-amount 0) (format " ±%d " text-scale-mode-amount) "Font scale")
    (mode-line-status-entry buffer-read-only              " RO "                                  "Buffer is read-only")
    (mode-line-status-entry vc-mode                       (concat " VC:" vc-mode " ")             vc-mode)
    (mode-line-status-entry isearch-mode                  (concat " search: " isearch-string " ") "isearch in progress")
    (mode-line-status-entry (and (>= 20 (my:battery-percent))
                                 (< (my:battery-percent) 100))
                            (my:battery-message) "Battery")

    ;;; NOTIFICATIONS: IMPORTANT STUFF
    (mode-line-notification-entry (and (buffer-modified-p) (buffer-file-name)) " !! "   "Buffer has been modified")
    (mode-line-notification-entry (buffer-narrowed-p)                          " >< "   "Buffer is narrowed")
    ;; (mode-line-notification-entry (< (my:battery-percent) 20) (my:battery-message) "Battery")

    ;; '(:eval (debug-window-focus))
    ;; '(:eval mode-line-frame-identification)

    (mode-line-str-dflt
     (let*
         ((gap (if (window-has-focus)
                 8
                 0)))
       (mode-line-fill mface gap)))

    '(:eval
     (when (window-has-focus)
       (mode-line-buffer-name-entry (format-time-string " %I:%M%p ") "")))))

#+END_SRC

** Frames and Windows

When my:use-frames is set, configure emacs to use popup frames. Also,
assume that we're using StumpWM & load it.

#+BEGIN_SRC emacs-lisp
(defun my:toggle-use-frames ()
  (interactive)
  (setq my:use-frames (not my:use-frames)
        pop-up-frames my:use-frames)
  (if my:use-frames
      (message "Using frames.")
    (message "Using windows.")))

(when my:use-frames
  (progn
    (require 'stumpwm-mode)
    (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
    (setq pop-up-frames t)))
#+END_SRC

** Buffers

Tell the =uniquify= package how to rename buffers.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
  '(uniquify-buffer-name-style 'post-forward nil (uniquify)))
#+END_SRC

Initialize the scratch buffer to =org-mode=.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
    '(initial-major-mode (quote org-mode))
    '(initial-scratch-message
     "This buffer is for text that is not saved, and for Lisp evaluation.
  To create a file, visit it with \\[find-file] and enter text in its buffer.

  ,#+BEGIN_SRC emacs-lisp

  ,#+END_SRC
  "))
#+END_SRC

** Scrolling

*DEACTIVATED*: Optionally, scroll on a per-pixel basis, like it's 1999 (rather than 1989). Based on advice on [[https://emacs.stackexchange.com/questions/10354/smooth-mouse-scroll-for-inline-images][StackOverflow]].

#+BEGIN_SRC
(pixel-scroll-mode)
(setq pixel-dead-time 0) ; Never go back to the old scrolling behaviour.
(setq pixel-resolution-fine-flag t) ; Scroll by number of pixels instead of lines (t = frame-char-height pixels).
(setq mouse-wheel-scroll-amount '(1)) ; Distance in pixel-resolution to scroll each mouse wheel event.
(setq mouse-wheel-progressive-speed nil) ; Progressive speed is too fast for me.
#+END_SRC

Don't do special processing for tall lines by default. Way too much cursor lag.

#+BEGIN_SRC emacs-lisp
(setq-default auto-window-vscroll nil)
#+END_SRC

* Theme

Load my theme.

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/emacs-config/themes/")
(load-theme 'bgutter t)
#+END_SRC

* File Associations

** Quick Mappings
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.plt\\'" . gnuplot-mode))
(add-to-list 'auto-mode-alist '("\\.m$"     . octave-mode ))
#+END_SRC

** Generic Modes

B2C, T2C, and F2C files

#+BEGIN_SRC emacs-lisp
(define-generic-mode
  '2c-mode                                   ; name of the mode to create
  '("*")                                     ; comments start with '!!'
  '("c_dep")                                 ; keywords
  nil                                        ; special words
  '("\\.t2c\\'"  "\\.b2c\\'" "\\.f2c\\'")    ; files for which to activate this mode
  '((lambda () (run-hooks 'prog-mode-hook))) ; other functions to call
  "A mode for B2C, T2C, & F2C files")        ; doc string for this mode
#+END_SRC

Monkey-C Mode

#+BEGIN_SRC emacs-lisp
(define-generic-mode
  'monkey-c-mode
  '("//")
  '("using" "as" "class" "extends" "function" "hidden" "return")
  '("initialize" "onUpdate")
  '("\\.mc\\'")
  '((lambda () (run-hooks 'prog-mode-hook)))
  "A mode for Monkey-C")
#+END_SRC

* Mode Management

Handle which modes/settings are triggered where.

** Global Default Modes

Truncate lines, don't wrap.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

Full Undo/Redo history as a tree

#+BEGIN_SRC emacs-lisp
(global-undo-tree-mode 1)
#+END_SRC

Don't use lockfiles....causes issues in SeaFile.

#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

Track recent files -- quite a lot of them.

#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items  2000)
(setq recentf-max-saved-items 2000)
#+END_SRC

Manage workspaces.

- Shift + left/right switches between tabs.
- Shift + up clones current tab to the right
- Shift + down deletes current tab and moves focus left

#+BEGIN_SRC emacs-lisp
(tab-bar-mode)
(custom-set-variables
   '(tab-bar-close-button-show nil)
   '(tab-bar-close-tab-select 'left)
   '(tab-bar-new-tab-choice nil)
   '(tab-bar-new-tab-to 'right)
   '(tab-bar-show 1)
   '(tab-bar-tab-hints t))
#+END_SRC

Help me with my keys

#+BEGIN_SRC emacs-lisp
(which-key-mode)
#+END_SRC

Enable counsel and ivy modes.

#+BEGIN_SRC emacs-lisp
(counsel-mode)
(ivy-mode)
#+END_SRC

Hide the toolbar, menu bar, and scroll bars.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode   -1)
(menu-bar-mode    0)
(scroll-bar-mode -1)
#+END_SRC

Use yasnippet everywhere.

#+BEGIN_SRC emacs-lisp
(yas-global-mode t)
#+END_SRC

Use ido by default.

#+BEGIN_SRC emacs-lisp
(ido-mode)
#+END_SRC

Let ido match strings flexibly.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'ido-enable-flex-matching t)
#+END_SRC

Always open files in the current window.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(ido-default-buffer-method (quote selected-window))
 '(ido-default-file-method (quote selected-window)))
#+END_SRC

Use pdf-tools for viewing PDF documents, rather than docview

#+BEGIN_SRC emacs-lisp
(pdf-tools-install t)
#+END_SRC

Emojis everywhere (except for some places).

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'global-emojify-mode)

(customize-set-variable 'emojify-inhibit-major-modes
    '(dired-mode doc-view-mode debugger-mode pdf-view-mode image-mode help-mode ibuffer-mode magit-popup-mode magit-diff-mode ert-results-mode compilation-mode proced-mode mu4e-headers-mode org-agenda-mode))

(defun my:emojify-inhibit-fix-org-drawers (text beg end)
  "Since org-mode now uses lower-case :begin:, :end:, etc tags, some of them are
now being rendered as Emojis. Filter this case out."
  (and (equal major-mode 'org-mode) (member (downcase text) '(":begin:" ":end:"))))

(add-to-list 'emojify-inhibit-functions 'my:emojify-inhibit-fix-org-drawers)
#+END_SRC

Unicode setup

#+BEGIN_SRC emacs-lisp
(unicode-fonts-setup)
#+END_SRC

If I trigger a self-insert key when region is active, I want the
selection to be replaced by that text.

#+BEGIN_SRC emacs-lisp
(delete-selection-mode)
#+END_SRC

Add the ability to undo/redo window arrangement changes.

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** Mode Triggers
*** prog-mode

The hook =prog-mode-hook= is triggered in all programming major-modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
  '(lambda ()
    (flyspell-prog-mode)
    (display-line-numbers-mode 1)
    (auto-highlight-symbol-mode)
    (rainbow-delimiters-mode)))
#+END_SRC

*** text-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
  (lambda ()
    (flyspell-mode)
    (visual-line-mode)
    (variable-pitch-mode t)
    (text-scale-increase 1)))
#+END_SRC

*** org-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
  (lambda ()
    (variable-pitch-mode -1)
    (org-autolist-mode)
    ;(auto-fill-mode)
    ;(visual-line-mode nil)
    ;(setq truncate-lines t)
    (olivetti-mode)
    (text-scale-increase 0)))
#+END_SRC

*** c-mode

Use employer's preferred C format...

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
  '(lambda ()
     (set 'c-basic-offset  4)
     (set 'c-electric-flag nil)
     (c-set-style "whitesmith")
     (setq comment-start "// ")
     (setq comment-end   "")))
#+END_SRC

*** octave-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'octave-mode-hook
  (lambda ()
    (local-set-key (kbd "C-\\") 'octave-send-region-or-line)))
#+END_SRC

*** compilation-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'compilation-mode-hook
  (lambda ()
    (visual-line-mode)
    (local-set-key (kbd "H-]") 'next-error)
    (local-set-key (kbd "H-[") 'previous-error)))
#+END_SRC

*** shell-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook
  (lambda ()
    (setq show-trailing-whitespace nil)
    (visual-line-mode t)))
#+END_SRC

*** python-mode
#+BEGIN_SRC emacs-lisp
(defun my/python-interrupt()
    (interactive)
    (let ((proc (ignore-errors
    (python-shell-get-process-or-error))))
    (when proc
      (interrupt-process proc))))

(add-hook 'python-mode-hook
  (lambda ()
    (jedi:setup)
    (local-set-key (kbd "<tab>")         'python-smart-tab-key)
    (local-set-key (kbd "TAB")           'python-smart-tab-key)
    (local-set-key (kbd "C-t")           'indent-for-tab-command)
    (local-set-key (kbd "<backspace>")   'backward-delete-char-untabify)
    (local-set-key (kbd "C-\\")          'run-python-in-shell)
    (local-set-key (kbd "C-r")           'align-current)
    (local-set-key (kbd "C-|")           'python-shell-send-buffer)
    (local-set-key (kbd "C-d")           'my/python-interrupt)))
#+END_SRC

*** ruby-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'ruby-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t") 'indent-for-tab-command)))
#+END_SRC

*** scheme-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'scheme-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t")   'indent-for-tab-command)))
#+END_SRC

*** emacs-lisp-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t")   'indent-for-tab-command)))
#+END_SRC

*** term-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'term-mode-hook
  (lambda ()
    (display-line-numbers-mode -1)
    (setq show-trailing-whitespace nil)
    (term-pager-toggle)))
#+END_SRC

*** web development

Use emmet in any web-dev modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'html-mode-hook 'emmet-mode)
(add-hook 'css-mode-hook 'emmet-mode)
#+END_SRC

*** csv-mode

Add a margin between columns, and center content.

#+BEGIN_SRC emacs-lisp
(custom-set-variables '(csv-align-padding 7)
                      '(csv-align-style 'centre))
#+END_SRC

Whenever we start =csv-mode=, freeze the first row & auto-align fields.

#+BEGIN_SRC emacs-lisp
(add-hook 'csv-mode-hook 'csv-align-mode)
(add-hook 'csv-mode-hook 'csv-header-line)
(add-hook 'csv-mode-hook (lambda () (visual-line-mode 0)))
#+END_SRC

*** sql-mode

Assume sqlite.

#+begin_src emacs-lisp
  (add-hook 'sql-mode-hook
    (lambda ()
      (sql-set-product 'sqlite)))
#+end_src

* Package Configurations
** org-mode
*** General Configs

Ensure that org-mode starts up using indentation.

#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
#+END_SRC

Mode hooks

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
  (lambda ()
    (text-scale-increase 0)
    (org-bullets-mode 1)))
#+END_SRC

Unhide areas when they're edited.

#+BEGIN_SRC emacs-lisp
(setq org-catch-invisible-edits 'show-and-error)
#+END_SRC

Colorize quote blocks like we do source blocks.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-fontify-quote-and-verse-blocks t)
#+END_SRC

Allow images to be visually resized with #+ATTR keywords.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-image-actual-width nil)
#+END_SRC

Adjust emphasis elements a bit.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-emphasis-alist
  '(("*" bold)
    ("/" italic)
    ("_" underline)
    ("=" org-verbatim verbatim)
    ("~" org-code verbatim)
    ("+"
     (:strike-through t))
    ("%" highlight verbatim)))
#+END_SRC

Adjust how columns are shown when enabled.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-columns-default-format "%25ITEM %TODO %3PRIORITY %TAGS")
#+END_SRC

Use a simple unicode bullet.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-bullets-bullet-list '("○"))
#+END_SRC

Any TODO which is tagged :noagenda: shouldn't be in the agenda.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-agenda-hide-tags-regexp "noagenda")
#+END_SRC

*** Modules

Set our org-modules.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-modules '(org-bbdb org-bibtex org-docview org-gnus org-habit org-info org-irc org-mhe org-rmail org-w3m org-collector))
#+END_SRC

Make easy template work again. Though the new expansion method looks pretty cool. [[https://github.com/syl20bnr/spacemacs/issues/11798][Discussion here.]]

#+begin_src emacs-lisp
(when (version<= "9.2" (org-version))
  (require 'org-tempo))
#+end_src

*** Export

Use minted code sections in PDF export, and fixup the margins a bit. Some code from the [[https://lists.gnu.org/archive/html/emacs-orgmode/2015-08/msg00122.html][GNU Mailing list]].

#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'minted
      org-latex-default-figure-position "H"
      org-latex-packages-alist '(("" "minted")
                                 ("margin=1.5cm" "geometry" nil)
                                 ("" "parskip")
                                 ("" "booktabs")
                                 ("" "float"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

 (setq org-latex-minted-options
  '(("fontfamily" "zi4")))
 ;;'(("linenos")
 ;;                   ("numbersep"   "5pt")
 ;;                  ("frame"       "none") ; box frame is created by the mdframed package
 ;;                   ("framesep"    "2mm")
                    ;; ("fontfamily"  "zi4") ; required only when using pdflatex
 ;;                                       ; instead of xelatex
 ;;                   ;; minted 2.0 specific features
  ;;                  ("breaklines") ; line wrapping within code blocks
   ;;                 ))

(customize-set-variable 'org-latex-minted-langs
   '((emacs-lisp "common-lisp")
     (cc "c++")
     (cperl "perl")
     (shell-script "bash")
     (caml "ocaml")
     (sqlite "sql")
     (ipython "python")))
#+END_SRC

Don't add a table of contents upon export.

#+BEGIN_SRC emacs-lisp
(setq org-export-with-toc nil)
#+END_SRC

Be consistent with caption placement.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-latex-caption-above nil)
#+END_SRC

Use two column layouts with 8pt font for reports and article document classes.

#+BEGIN_SRC emacs-lisp
(setq org-latex-classes
  '(("article" "\\documentclass[8pt,twocolumn]{article}"
    ("\\section{%s}" . "\\section*{%s}")
    ("\\subsection{%s}" . "\\subsection*{%s}")
    ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
    ("\\paragraph{%s}" . "\\paragraph*{%s}")
    ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
  ("report" "\\documentclass[8pt,twocolumn]{report}"
    ("\\part{%s}" . "\\part*{%s}")
    ("\\chapter{%s}" . "\\chapter*{%s}")
    ("\\section{%s}" . "\\section*{%s}")
    ("\\subsection{%s}" . "\\subsection*{%s}")
    ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
 ("book" "\\documentclass[11pt]{book}"
   ("\\part{%s}" . "\\part*{%s}")
   ("\\chapter{%s}" . "\\chapter*{%s}")
   ("\\section{%s}" . "\\section*{%s}")
   ("\\subsection{%s}" . "\\subsection*{%s}")
   ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+END_SRC

*** Agenda

Define org todo keywords.

Current Tags:
|-----------+--------------------------------------------------------------------------------------------------|
| tag       | Use                                                                                              |
|-----------+--------------------------------------------------------------------------------------------------|
| TODO      | Items which are queued to be completed.                                                          |
| NEXT      | Items which are considered to be in-progress. Max 3-5 items at any point in time.                |
| WAIT      | Items which are blocked by an external party.                                                    |
| DONE      | Items which have been completed as described.                                                    |
| CANCELLED | Items which will not be completed.                                                               |
| HIATUS    | "Soft-cancelled". Items which were originally TODO'd, but for some reason, may not ever be done. |
| MIGRATED  | Items which have been made redundant by newer entries.                                           |
|-----------+--------------------------------------------------------------------------------------------------|

Deprecated Tags:
|-------------+------------------------|
| tag         | Use                    |
|-------------+------------------------|
| IN_PROGRESS | Previous name for NEXT |
| PENDING     | Previous name for WAIT |
|-------------+------------------------|

#+BEGIN_SRC emacs-lisp
(setq-default org-todo-keywords
  '((sequence "TODO(t!)" "IN_PROGRESS(i!)" "NEXT(n!)" "PENDING(p!)" "WAIT(w!)" "|" "DONE(d!)" "CANCELLED(c!)" "HIATUS(h!)" "MIGRATED(m!)")))
#+END_SRC

And their faces.

#+BEGIN_SRC emacs-lisp
(setq-default org-todo-keyword-faces
      '(( "TODO" .        (:foreground "white"      :background "darkorchid4"  :weight bold              ))
        ( "IN_PROGRESS" . (                         :background "deeppink3"    :weight bold              ))
        ( "NEXT" .        (                         :background "deeppink3"    :weight bold              ))
        ( "HIATUS" .      (:foreground "white"                                              :slant italic))
        ( "DONE" .        (:foreground "white"      :background "forest green" :weight bold              ))
        ( "CANCELLED" .   (:foreground "light gray"                                         :slant italic))
        ( "FAILED" .      (:foreground "white"      :background "red"          :weight bold              ))
        ( "MIGRATED"      (:foreground "light gray"                                         :slant italic))
        ( "PENDING"       (:foreground "light gray"                                         :slant italic))
        ( "WAIT"          (                         :background "Red"          :weight bold              ))))
#+END_SRC

And their priorities:
|----------+----------------------------------------------|
| priority | Meaning                                      |
|----------+----------------------------------------------|
| *A*      | This is critical and urgent                  |
| *B*      | This is very important and/or time sensitive |
| *C*      | Needs to happen in the near future.          |
| *D*      | Would be cool to do this.                    |
| *E*      | Just an idea. Whatever.                      |
|----------+----------------------------------------------|

#+BEGIN_SRC emacs-lisp
(setq org-highest-priority ?A)
(setq org-lowest-priority  ?E)
(setq org-default-priority ?B)
(setq org-priority-faces '((?A . (:foreground "white" :background "dark red" :weight bold))
                           (?B . (:foreground "white" :background "dark green" :weight bold))
                           (?C . (:foreground "green" :weight bold))
                           (?D . (:foreground "yellow"))
                           (?E . (:foreground "gray"))))
#+END_SRC

Uncomplicate agenda fonts.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-deadline-faces '((1.0 . org-upcoming-deadline)
                                  (0.0 . (:foreground "light pink" :slant italic))))
#+END_SRC

Show state changes in org-agenda log mode.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-log-mode-items '(closed clock state))
#+END_SRC

Log into drawer (LOGBOOK)

#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer t)
#+END_SRC

Open agenda in current window.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'current-window)
#+END_SRC

Mark items closed, as many times as needed.

#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
(setq org-closed-keep-when-no-todo t)
#+END_SRC

Hide items scheduled in future from org-todo list.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-todo-ignore-scheduled 'future)
#+END_SRC

Unclutter the agenda display.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-agenda-prefix-format
    '((agenda . " %i %?-12t% s")
      (todo . " ")
      (tags . " ")
      (search . " %i %-12:c")))
#+END_SRC

I want to be able to have multiple agenda windows.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-agenda-sticky t)
#+END_SRC

Add custom agenda command, use some awesome code from [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][this blog]] and [[https://stackoverflow.com/questions/10074016/org-mode-filter-on-tag-in-agenda-view/33444799#33444799][this StackOverflow user]].

#+BEGIN_SRC emacs-lisp
(defcustom my:work-tag               nil "Name of org-mode work tag")

(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(defun air-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))

(defun air-org-skip-subtree-unless-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        nil
      subtree-end)))

(defun cmp-date-property (prop)
  "Compare two `org-mode' agenda entries, `A' and `B', by some date property.

If a is before b, return -1. If a is after b, return 1. If they
are equal return t."
  (lexical-let ((prop prop))
  #'(lambda (a b)

    (let* ((a-pos (get-text-property 0 'org-marker a))
           (b-pos (get-text-property 0 'org-marker b))
           (a-date (or (org-entry-get a-pos prop)
                       (format "<%s>" (org-read-date t nil "now"))))
           (b-date (or (org-entry-get b-pos prop)
                       (format "<%s>" (org-read-date t nil "now"))))
           (cmp (compare-strings a-date nil nil b-date nil nil))
           )
      (if (eq cmp t) nil (signum cmp))
      ))))

(defun zin/org-agenda-skip-tag (tag &optional others)
  "Skip all entries that correspond to TAG.

If OTHERS is true, skip all entries that do not correspond to TAG.
https://emacs.stackexchange.com/questions/26351/custom-sorting-for-agenda"
  (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
        (current-headline (or (and (org-at-heading-p)
                                   (point))
                              (save-excursion (org-back-to-heading)))))
    (if others
        (if (not (member tag (org-get-tags-at current-headline)))
            next-headline
          nil)
      (if (member tag (org-get-tags-at current-headline))
          next-headline
        nil))))

(let*
    ((work-str      (symbol-name my:work-tag))
     (omit-work-str (concat "-" work-str)))
  (setq org-agenda-custom-commands
      `(("d" "Daily agenda and all TODOs"
         (
          (agenda "" ((org-agenda-span 7)
                      (org-agenda-skip-function 'air-org-skip-subtree-if-habit)
                      (org-agenda-overriding-header "Weekly Agenda:")))
          (agenda "" ((org-agenda-span 1)
                      (org-agenda-skip-function 'air-org-skip-subtree-unless-habit)
                      (org-agenda-overriding-header "Open Habits:")))
          (alltodo ""
                   ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                   (org-agenda-skip-if nil '(scheduled deadline))))
                    (org-agenda-overriding-header "Incomplete Unscheduled Tasks:"))))
         ((org-agenda-compact-blocks nil)))

        ("h" "Habits"
         (
          (agenda "" ((org-agenda-span 1)
                      (org-agenda-skip-function 'air-org-skip-subtree-unless-habit)
                      (org-agenda-overriding-header "Open Habits:"))))
        ((org-agenda-compact-blocks nil)))

        ("w" "Filtered Weekly Agenda"
         (
          (agenda "" ((org-agenda-span 7)
                      (org-agenda-skip-function 'air-org-skip-subtree-if-habit)
                      (org-agenda-overriding-header "Weekly Agenda:"))))
         ((org-agenda-compact-blocks nil)))

         ("u" "Incomplete, Unscheduled TODO List (non-work)"
         (
          (alltodo ""
                   ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                   (org-agenda-skip-if nil '(scheduled deadline))))
                    (org-agenda-overriding-header "Incomplete Unscheduled Tasks:")
                    (org-agenda-tag-filter-preset '(,omit-work-str)))))
         ((org-agenda-compact-blocks nil)))

         ("m" "Closed in Past Month:"
          tags (concat "+TODO={DONE\\|CANCELLED\\|HIATUS}"
                        "+CLOSED>=\""
                                    (format-time-string "[%Y-%m-%d]" (time-subtract (current-time) (days-to-time 30)))
                                     "\"")
                ((org-agenda-overriding-header "Recently Closed:")
                 (org-agenda-cmp-user-defined (cmp-date-property "CLOSED")) ;; https://emacs.stackexchange.com/questions/26351/custom-sorting-for-agenda
                 (org-agenda-sorting-strategy '(user-defined-down))))

         ("x" "Combined Task List"
           (

           (todo "NEXT"
                   ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                   ;;(zin/org-agenda-skip-tag ,work-str)
                                                   (zin/org-agenda-skip-tag "NOAGENDA")))
                    (org-agenda-overriding-header "Your Current Plate:")
                    ;;(org-agenda-compact-blocks t)
                    ))

          (todo "WAIT"
                   ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                   ;;(zin/org-agenda-skip-tag ,work-str)
                                                   (zin/org-agenda-skip-tag "NOAGENDA")))
                    (org-agenda-overriding-header "Blocked Tasks:")
                    ;;(org-agenda-compact-blocks t)
                    ))

           (alltodo ""
                   ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                   (org-agenda-skip-entry-if 'todo '("NEXT" "Wait"))
                                                   ;;(zin/org-agenda-skip-tag ,work-str)
                                                   (zin/org-agenda-skip-tag "NOAGENDA")))
                    (org-agenda-overriding-header "Other Tasks:")
                    ;;(org-agenda-compact-blocks t)
                    ))

           ;(tags (concat "+TODO={DONE}"
           ;             "+CLOSED>=\""
           ;                         (format-time-string "[%Y-%m-%d]" (time-subtract (current-time) (days-to-time 7)))
           ;                          "\"")
           ;     ((org-agenda-overriding-header "Recently Completed:")
           ;      (org-agenda-cmp-user-defined (cmp-date-property "CLOSED")) ;; https://emacs.stackexchange.com/questions/26351/custom-sorting-for-agenda
           ;      (org-agenda-sorting-strategy '(user-defined-down))
           ;      (org-agenda-max-entries 10)))

           ;(tags (concat "+TODO={CANCELLED}"
           ;             "+CLOSED>=\""
           ;                         (format-time-string "[%Y-%m-%d]" (time-subtract (current-time) (days-to-time 7)))
           ;                          "\"")
           ;     ((org-agenda-overriding-header "Recently Cancelled:")
           ;      (org-agenda-cmp-user-defined (cmp-date-property "CLOSED")) ;; https://emacs.stackexchange.com/questions/26351/custom-sorting-for-agenda
           ;      (org-agenda-sorting-strategy '(user-defined-down))
           ;      (org-agenda-max-entries 5)))

           ;(alltodo ""
           ;        ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
           ;                                        (zin/org-agenda-skip-tag ,work-str 't)
           ;                                        (zin/org-agenda-skip-tag "NOAGENDA")))
           ;         (org-agenda-overriding-header "Work Tasks:")))
           )))))
#+END_SRC

Don't show blocked tasks (ORDERED property set to t)

#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t
      org-agenda-dim-blocked-tasks 'invisible)
#+END_SRC

Show past week and next two in agenda view.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook
  (lambda ()
    (setq org-agenda-span 21
          org-agenda-start-on-weekday nil
          org-agenda-start-day "-7d")))
#+END_SRC

*** Babel

Enable IPython, shell commands, Common Lisp, and Elasticsearch queries
from code blocks.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (progn
    (org-babel-do-load-languages
      'org-babel-load-languages
      '((python . t)
        (emacs-lisp . t)
        (ipython . t)
        (shell . t)
        (lisp . t)
        (elasticsearch . t)
        (R . t)
        (ruby . t)
        (sqlite . t)
        (plantuml . t)))))
#+END_SRC

Plantuml blocks also need some special attention to get working. Hope this is consistent across distros; this is the correct value for Ubuntu/WSL Xenial.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
#+END_SRC

Display images after each eval

#+BEGIN_SRC emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+END_SRC

Track boldness, italics for many lines.

#+BEGIN_SRC emacs-lisp
(setcar (nthcdr 4 org-emphasis-regexp-components) 10)
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

Map file extensions to external programs which open them. org-mode
uses this when following file links.

#+BEGIN_SRC emacs-lisp
(setq org-file-apps
  '((auto-mode . emacs)
     ("\\.ods" . "libreoffice %s")))
#+END_SRC

Live fearlessly.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

Apparently org block switches are a thing that exist, and have nothing to do with org block header arguments...? You need them to enable line numbers in exported blocks, but the current implementation of switches is...partial.

Tobias posted this code on [[https://emacs.stackexchange.com/questions/33971/is-it-possible-to-define-source-block-switches-globally-in-org-mode][the Emacs StackExchange]] which implements the buffer-global property syntax for switches. It's like this:

#+BEGIN_EXAMPLE
    #+PROPERTY: switches: -n
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(require 'cl-lib)
(require 'org)
(require 'ox)
(require 'org-element)

(defvar org-src-switch-alist nil
  "Alist mapping an org source code switches to its argument parser (which can be nil) and its interpreter.")
(setq org-src-switches-alist
  '(("-n" org-src-parse-number (lambda (num) (list :number-lines (cons 'new (or num 0)))))
    ("+n" org-src-parse-number (lambda (num) (list :number-lines (cons 'continued (or num 0)))))
    ("-r" nil (:retain-labels nil))
    ("-i" nil (:preserve-indent t))
    ("-l" org-src-parse-quoted-string (lambda (str) (assert (stringp str)) (list :label-fmt str)))
    ("-k" nil (:use-labels t))))

(defun org-src-parse-number ()
  "Parse number at point and return it as the only element of a list.
If parsing fails the return value is (nil)."
  (list
   (when (looking-at "[0-9]")
     (read (current-buffer)))))

(defun org-src-parse-quoted-string ()
  "Parse quoted string at point and return it as the only element of a list.
If parsing fails the return value is (nil)."
  (list
   (when (looking-at "\"")
     (read (current-buffer)))))

(defun org-src-switch-parse (str)
  "Parse org mode source block switches in string STR."
  (let ((sw-re (regexp-opt (mapcar 'car org-src-switches-alist)))
        ret)
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (while (progn
               (skip-syntax-forward  " ")
               (looking-at sw-re))
        (goto-char (match-end 0))
        (let* ((sw (assoc-string (match-string 0) org-src-switches-alist))
               (parser (cadr sw))
               (interpreter (nth 2 sw))
               args)
          (skip-syntax-forward " ")
          (when parser
            (setq args (funcall parser)))
          (setq ret
                (append
                 ret
                 (if (functionp interpreter)
                     (apply interpreter args)
                   interpreter))))))
    ret))

(defun org-src-switch-propagate (keyword-element)
  (let ((value
         (and (string-equal (org-element-property :key keyword-element) "PROPERTY")
              (org-element-property :value keyword-element))))
    (when (and value (string-match "switches:" (downcase value)))
      (setq value (org-src-switch-parse (substring value (match-end 0))))
      (let ((parent (org-element-property :parent keyword-element)))
    (when (and
           (eq (org-element-type parent) 'section)
           (eq (org-element-type (org-element-property :parent parent)) 'org-data))
      (setq parent (org-element-property :parent parent)))
    (org-element-map
        parent
        '(src-block example-block)
      `(lambda (bl)
         (cl-loop for pair on ',value by 'cddr
              do (org-element-put-property bl (car pair) (cadr pair)))))))))

(defun org-element-parse-buffer-ad (info)
  "Filter the INFO returned by `org-element-parse-buffer' for global switches
and apply them to source code blocks."
  (org-element-map info 'keyword #'org-src-switch-propagate)
  info)

(advice-add #'org-element-parse-buffer :filter-return #'org-element-parse-buffer-ad)
#+END_SRC

When editing source blocks in indirect buffers, open them in the current window. Do not mess with the window layout.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'org-src-window-setup 'current-window)
#+END_SRC

*** Habit Tracking

Sort org-habits by priority. See [[https://emacs.stackexchange.com/questions/32430/how-to-sort-habits-by-priority-in-the-org-agenda-view][StackOverflow]].

#+BEGIN_SRC emacs-lisp
(defun hw-org-agenda-sort-habits (a b)
  "Sort habits first by user priority, then by schedule+deadline+consistency."
  (let ((ha (get-text-property 1 'org-habit-p a))
        (hb (get-text-property 1 'org-habit-p b)))
    (when (and ha hb)
      (let ((pa (org-get-priority a))
            (pb (org-get-priority b)))
        (cond ((> pa pb) +1)
              ((< pa pb) -1)
              ((= pa pb) (org-cmp-values a b 'priority)))))))
(setq org-agenda-cmp-user-defined 'hw-org-agenda-sort-habits
      org-agenda-sorting-strategy '((agenda time-up user-defined-down habit-down)
                                    (todo priority-down category-keep)
                                    (tags priority-down category-keep)
                                    (search category-keep)))
#+END_SRC

Customize the habit display a bit.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
  '(org-habit-completed-glyph 88)
  '(org-habit-following-days 0)
  '(org-habit-graph-column 90)
  '(org-habit-preceding-days 0)
  '(org-habit-today-glyph 124))
#+END_SRC

*** Personal Journal

Defcustoms for various personal definitions.

#+BEGIN_SRC emacs-lisp
(defcustom my:org-scraps-path         nil "Writing prompts and scraps")
(defcustom my:org-dream-journal-path  nil "Dream journal file path")
(defcustom my:org-file-tree-base-path nil "Base directory of my org directory structure")
#+END_SRC

Add function to rebuild org file list. Call it once.

#+BEGIN_SRC emacs-lisp
(defun my-org-update-agenda-index()
  (interactive)
  (setq org-agenda-files
    (seq-filter
      (lambda (x) (not (my:fname-seafile-conflict-p x)))
      (directory-files-recursively my:org-file-tree-base-path ".*\\.org$"))))
(when my:org-file-tree-base-path
  (my-org-update-agenda-index))
#+END_SRC

Add function to interactively select an existing concept file.

#+BEGIN_SRC emacs-lisp
  (defun my-org-list-concepts ()
    (seq-filter (lambda (path)
                  (and (file-directory-p path)
                       (file-exists-p (concat path "/concept.org"))))
                (directory-files-recursively (concat my:org-file-tree-base-path "/concepts/") ".*" t)))

  (defun my-org-find-concept ()
    (call-interactively
      (lambda (choice)
        (interactive
          (list (ivy-read "Existing Concepts: "
            (my-org-list-concepts))))
          (concat choice "/concept.org"))))

(defun my:org-concept-open ()
  (interactive)
  (find-file (my-org-find-concept)))
#+END_SRC

Add function to insert link to existing concept.

#+BEGIN_SRC emacs-lisp
(defun my:org-insert-concept-link ()
  (interactive)
  (let
    ((file (my-org-find-concept)))
   (org-insert-link nil file)))
#+END_SRC

Add function to search existing concepts, journals, etc.

#+BEGIN_SRC emacs-lisp
(defun my:org-search-concept ()
  (interactive)
  (counsel-ag "" my:org-file-tree-base-path))
#+END_SRC

Functions for creating and opening daily journal pages.

#+BEGIN_SRC emacs-lisp
(defvar my:journal-expansion-time nil
  "Temporarily bound to a date when the journal yasnippet should expand to dates other than today.")

(defun my-org-journal-current-day-path ()
  "Get the path to today's journal file."
  (my-org-journal-path (current-time)))

(defun my-org-journal-path (time)
  "Get the path to some day's journal file, given time (compatible with (current-time))."
  (let*
  ((journal-root (concat my:org-file-tree-base-path "/journal/"))
    (filename     "journal.org")
    (path (concat journal-root (format-time-string "%Y/%m/%e/" time) filename)))
    path))

(defun my-org-journal-make-if-missing (&optional time)
  "Unless already present, create a journal ORG file for today from the existing template."
  (interactive)
  (setq time (or time (current-time)))
  (let
   '(path (my-org-journal-path time))
  (progn
    (save-excursion
      (unless (file-exists-p path)
        (progn
          (make-directory (file-name-directory path) t)
          (find-file path)
          (let ((my:journal-expansion-time time))
            (yas-expand-snippet (yas-lookup-snippet "Journal Page Template" 'org-mode)))
          (save-buffer)
          (kill-buffer)
          (my-org-update-agenda-index))))
     path)))

(defun my-org-journal-open-today ()
  "Open today's journal file, creating it if missing."
  (interactive)
  (let ((time (current-time)))
      (my-org-journal-make-if-missing time)
      (find-file (my-org-journal-path time))))

(defun my-org-journal-open-yesterday ()
  "Open yesterday's journal file, creating it if missing."
  (interactive)
  (let ((time (time-subtract (current-time) (seconds-to-time (* 60 60 24)))))
      (my-org-journal-make-if-missing time)
      (find-file (my-org-journal-path time))))

(defun my-org-journal-open-tomorrow ()
  "Open tomorrow's journal file, creating it if missing."
  (interactive)
  (let ((time (time-add (current-time) (seconds-to-time (* 60 60 24)))))
      (my-org-journal-make-if-missing time)
      (find-file (my-org-journal-path time))))
#+END_SRC

Advise org-save-all-org-buffers to autocommit any changes in my org folder

#+BEGIN_SRC emacs-lisp
(defun my:org-autocommit-get-message ()
  "Return a string for an org autocommit commit message.
   I use YYYY-MM-DD HH:MM:SS:ms"
  (prin1-to-string
    (string-join
      (list
        (format-time-string "%Y-%m-%d %I:%M:%S:%3N")
        ""
        (shell-command-to-string (concat "cd " my:org-file-tree-base-path " && git status --porcelain")))
      "\n")))

(defun my:org-autocommit ()
  "Automatically add/update files in the org dir."
  (interactive)
  (when my:commit-org
    (shell-command (concat "cd " my:org-file-tree-base-path " && git add -A && git commit -m " (my:org-autocommit-get-message)))))

(defadvice org-save-all-org-buffers
    (after my:org-save-all-org-buffers-autocommit activate)
    (my:org-autocommit))
#+END_SRC

*** Capture

Define org-capture templates.

|------+--------------------------------------------------------------------------------------------------------|
| Code | Purpose                                                                                                |
|------+--------------------------------------------------------------------------------------------------------|
| j    | Journal Entries. Writes a timestamped heading under the "Thoughts" section of today's journal.org      |
| u    | Unscheduled/unplanned TODO items, written to today's journal.org. Prompts for priority.                |
| c    | Concept-based TODO items, written to that concept's concept.org file. Prompts for concept and priority |
| d    | Dream journal entries. Writes a timestamped heading to the dreams/journal concept file.                |
| p    | Writing prompts and scraps. Writes timestamped section to the writing scraps file.                     |
|------+--------------------------------------------------------------------------------------------------------|

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates

      `(("j"
        "journal"
        entry
        (file+headline my-org-journal-make-if-missing "Thoughts")
        "** %U %?"
        :empty-lines 1)

       ("w"
        "Ad Hoc Task"
        entry
        (file+headline my-org-journal-make-if-missing "Ad Hoc Tasks")
        "** %? :%^{Type|talking|texting|meetings|coding|planning|downtime|clerical|tooling|analysis}:"
        :empty-lines 1
        :clock-in t
        :clock-keep t)

       ("y"
       "Work Log - Silent"
        entry
        (file+headline my-org-journal-make-if-missing "Ad Hoc Tasks")
        "** %?"
        :empty-lines 1
        :clock-in t
        :clock-keep t)

       ("u"
        "unscheduled task"
        entry
        (file+headline my-org-journal-make-if-missing "Action Items")
        "** TODO [#%^{Priority|C|A|B|D|E}] %?
:LOGBOOK:
- State \"TODO\"       from              %U
:END:"
        :empty-lines 1)

       ("c"
        "Concept Task"
        entry
        (file+headline my-org-find-concept "Action Items")
        "** TODO [#%^{Priority|C|A|B|D|E}] %?
:LOGBOOK:
- State \"TODO\"       from              %U
:END:"
        :empty-lines 1)

       ("d"
        "Dream Journal"
        entry
        (file+headline ,my:org-dream-journal-path "Dream Log")
        "** %U\n%?"
        :prepend t
        :empty-lines 1)

       ("p"
        "Writing Prompt"
        plain
        (file+headline ,my:org-scraps-path "Scraps")
        "%U\n%?"
        :prepend t
        :empty-lines 1)))
#+END_SRC

Add a function to rapidly clock into a new task without any information.

#+BEGIN_SRC emacs-lisp
(defun my:org-clock-new-task-silent ()
  "Create new ad hoc task & clock in -- don't do anything interactively."
  (interactive)
  (org-capture nil "y")
  (org-capture-finalize))
#+END_SRC

*** Refile

Set the refile targets to be all org files in my tree, and show the full path.

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9)))
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-use-outline-path 'full-file-path)
#+END_SRC

I want new items placed at the top of headings.

#+BEGIN_SRC emacs-lisp
(setq org-reverse-note-order t)
#+END_SRC

Refile a heading to a file+heading+datetree, using the date of the first timestamp in the heading as the date.

This is copied from Alphapapa's [[https://github.com/alphapapa/unpackaged.el#refile-to-datetree-file-using-earliestlatest-timestamp-in-entry][unpackaged.el]].

#+BEGIN_SRC emacs-lisp
  (defun unpackaged/org-refile-to-datetree-using-ts-in-entry (which-ts file &optional subtree-p)
    "Refile current entry to datetree in FILE using timestamp found in entry.
  WHICH should be `earliest' or `latest'. If SUBTREE-P is non-nil,
  search whole subtree."
    (interactive (list (intern (completing-read "Which timestamp? " '(earliest latest)))
                       (read-file-name "File: " (concat org-directory "/") nil 'mustmatch nil
                                       (lambda (filename)
                                         (string-suffix-p ".org" filename)))
                       current-prefix-arg))
    (require 'ts)
    (let* ((sorter (pcase which-ts
                     ('earliest #'ts<)
                     ('latest #'ts>)))
           (tss (unpackaged/org-timestamps-in-entry subtree-p))
           (ts (car (sort tss sorter)))
           (date (list (ts-month ts) (ts-day ts) (ts-year ts))))
      (unpackaged/org-refile-to-datetree file :date date)))

  (defun unpackaged/org-timestamps-in-entry (&optional subtree-p)
    "Return timestamp objects for all Org timestamps in entry.
   If SUBTREE-P is non-nil (interactively, with prefix), search
   whole subtree."
    (interactive (list current-prefix-arg))
    (save-excursion
      (let* ((beg (org-entry-beginning-position))
             (end (if subtree-p
                      (org-end-of-subtree)
                    (org-entry-end-position))))
        (goto-char beg)
        (cl-loop while (re-search-forward org-tsr-regexp-both end t)
                 collect (ts-parse-org (match-string 0))))))

  (cl-defun unpackaged/org-refile-to-datetree (file &key (date (calendar-current-date)) entry)
    "Refile ENTRY or current node to entry for DATE in datetree in FILE."
    (interactive (list (read-file-name "File: " (concat org-directory "/") nil 'mustmatch nil
                                       (lambda (filename)
                                         (string-suffix-p ".org" filename)))))
    ;; If org-datetree isn't loaded, it will cut the tree but not file
    ;; it anywhere, losing data. I don't know why
    ;; org-datetree-file-entry-under is in a separate package, not
    ;; loaded with the rest of org-mode.
    (require 'org-datetree)
    (unless entry
      (org-cut-subtree))
    ;; Using a condition-case to be extra careful. In case the refile
    ;; fails in any way, put cut subtree back.
    (condition-case err
        (with-current-buffer (or (org-find-base-buffer-visiting file)
                                 (find-file-noselect file))
          (org-datetree-file-entry-under (or entry (car kill-ring)) date)
          (save-buffer))
      (error (unless entry
               (org-paste-subtree))
             (message "Unable to refile! %s" err))))
#+END_SRC

Refiling utility based on [[https://emacs.stackexchange.com/questions/8045/org-refile-to-a-known-fixed-location][this StackOverflow question]].

#+BEGIN_SRC emacs-lisp
  (defun jay/refile-to (file headline)
      "Move current headline to specified location"
      (let ((pos (save-excursion
                   (find-file file)
                   (org-find-exact-headline-in-buffer headline))))
        (org-refile nil nil (list headline file nil pos))))
#+END_SRC

Custom refile functions.

#+BEGIN_SRC emacs-lisp
  (defmacro my:define-refiler (fname filename-form &optional headline-option)
    "Macro which defines a function which refiles the heading under point to
  the filename to which `filename-form' evaluates. `fname' will be the name of
  that function.
    If `headline-option' is 'datetree, then content will be refiled into a datetree
  in that file. Heading will not be prompted."
    `(defun ,fname ()
      (interactive)
      (let ((target-file-path ,filename-form)
            (target-headline (and (not ,headline-option)
                                  (ivy-read "Target Heading:" '("Thoughts" "Action Items")))))

        ;; Create heading if missing in that file
        (when target-headline
          (save-excursion
            (find-file target-file-path)
            (unless (org-find-exact-headline-in-buffer target-headline)
              (end-of-buffer)
              (newline)
              (insert (concat "* " target-headline)))))

        ;; Do the refile
        (pcase ,headline-option
          ('datetree      (save-excursion
                            (unpackaged/org-refile-to-datetree-using-ts-in-entry 'earliest target-file-path t)))
          ((pred stringp) (progn
                            (org-mark-ring-push)
                            (jay/refile-to target-file-path ,headline-option)
                            (org-mark-ring-goto)))
          (-              (progn
                            (org-mark-ring-push)
                            (jay/refile-to target-file-path target-headline)
                            (org-mark-ring-goto)))))))

  (my:define-refiler my:org-refile-as-concept (my-org-find-concept))
  (my:define-refiler my:org-refile-as-journal (my-org-journal-make-if-missing))
  (my:define-refiler my:org-refile-as-dream my:org-dream-journal-path 'datetree)
  (my:define-refiler my:org-refile-as-scrap my:org-scraps-path "Scraps")

  (define-transient-command my:org-refile-transient ()
    "Wrapper for org-refile with some personal shortcuts and behaviors."
    ["Refile Heading As..."
     ("c" "Concept" my:org-refile-as-concept)
     ("j" "Journal" my:org-refile-as-journal)
     ("s" "Scrap"   my:org-refile-as-scrap)
     ("d" "Dream"   my:org-refile-as-dream)
     ("o" "Other"   org-refile)
     ])
#+END_SRC

Always save all files after a refile. A little surprised the files aren't saved automatically. From [[https://emacs.stackexchange.com/questions/26923/org-mode-getting-errors-when-auto-saving-after-refiling][StackOverflow]].

#+BEGIN_SRC emacs-lisp
(advice-add 'org-refile :after
  (lambda (&rest _)
    (org-save-all-org-buffers)))
#+END_SRC

** python-mode

Use IPython

#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "--simple-prompt -i")
#+END_SRC

Use Jedi

#+BEGIN_SRC emacs-lisp
(setq jedi:complete-on-dot nil)
#+END_SRC

** yasnippet

Set the snippet dir

#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs '("~/.emacs.d/emacs-config/snippets"))
(yas-reload-all)
#+END_SRC

** org-caldav

Configure calDAV server. Defcustoms used so that I can occasionally
share this file on GitHub without needing to sanitize as much.

#+BEGIN_SRC emacs-lisp
(defcustom my:org-ical-timezone      nil "Timezone used for org-caldav")
(defcustom my:org-caldav-url         nil "URL used by org-caldav")
(defcustom my:org-caldav-calendar-id nil "ID used by org-caldav")

(if (and my:org-caldav-calendar-id my:org-ical-timezone my:org-caldav-url)
  (setq org-caldav-url         my:org-caldav-url
        org-caldav-calendar-id my:org-caldav-calendar-id
        org-caldav-inbox       (concat my:org-file-tree-base-path "/calendar.org")
        org-icalendar-timezone my:org-ical-timezone
        org-caldav-files       '()))
#+END_SRC

** ivy

Include recentf in =ivy-switch-buffer=

#+BEGIN_SRC emacs-lisp
(setq ivy-use-virtual-buffers t)
#+END_SRC

** calfw

Change the theme a bit -- for whatever reason this wasn't defcustom'd.

#+BEGIN_SRC emacs-lisp
(setq-default cfw:org-face-agenda-item-foreground-color "Pink")
#+END_SRC

** slime

Use the default Roswell implementation, if it exists. Else, SBCL.

To install Roswell on Arch:

#+begin_src sh
yay -S roswell
ros install sbcl
ros install slime
#+end_src

#+BEGIN_SRC emacs-lisp
(if (file-directory-p "~/.roswell")
    (progn
      (load (expand-file-name "~/.roswell/helper.el"))
      (setq inferior-lisp-program "ros -Q run"))
  (setq inferior-lisp-program "sbcl"))
#+END_SRC

Show information about symbol at point in echo area.

#+BEGIN_SRC emacs-lisp
(add-to-list 'slime-contribs 'slime-autodoc)
(add-hook 'slime-mode-hook
  (lambda ()
    (slime-autodoc-mode)
    (set-up-slime-ac)
    (auto-complete-mode)))
#+END_SRC

** EMMS

Per the quickstart

#+BEGIN_SRC emacs-lisp
(emms-standard)
(emms-default-players)
#+END_SRC

Add function which calls some function (presumably related to music
playback), then echos the current track.

#+BEGIN_SRC emacs-lisp
(defun my:emms-do-then-show (func)
  "Call func interactively, then show current track."
  (call-interactively func)
  (sit-for 0.01) ;; else EMMS will say nothing is playing.
  (emms-show))
#+END_SRC

** conda

Configure the conda package such that we always use the Conda
environment (rather then system Python).

#+BEGIN_SRC emacs-lisp
(conda-env-initialize-interactive-shells)
(conda-env-initialize-eshell)
(conda-env-autoactivate-mode t)
#+END_SRC

** AHS

Jump through all occurrences in buffer.

#+BEGIN_SRC emacs-lisp
(setq ahs-default-range 'ahs-range-whole-buffer)
#+END_SRC

Only search code.

#+BEGIN_SRC emacs-lisp
(setq ahs-inhibit-face-list '(font-lock-comment-delimiter-face
                                font-lock-comment-face
                                font-lock-doc-face
                                font-lock-doc-string-face
                                font-lock-string-face))
#+END_SRC

Set delay for AHS highlighting.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'ahs-idle-interval 0.25)
#+END_SRC

** notmuch

Newest emails first.

#+BEGIN_SRC emacs-lisp
(setq notmuch-search-oldest-first nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq send-mail-function 'smtpmail-send-it)
#+END_SRC

** proced

Auto-update =proced= buffers.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
  '(proced-auto-update-flag t)
  '(proced-auto-update-interval 1))
#+END_SRC

** bookmarks

Always recenter when jumping between bookmarks.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'bm-recenter t)
#+END_SRC

Highlighting is done by line.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'bm-highlight-style 'bm-highlight-only-line)
#+END_SRC

** CLHS

Tell =clhs.el= to read my local copy of the CLHS.

#+BEGIN_SRC emacs-lisp
(defcustom my:website-archive-root nil "Root directory of my website archives.")

(customize-set-variable 'common-lisp-hyperspec-root
  (concat my:website-archive-root "clhs"))
#+END_SRC

** eww

Don't need to see trailing whitespace here -- I won't be fixing it.

#+BEGIN_SRC emacs-lisp
(add-hook 'eww-mode-hook
  (lambda ()
    (setq show-trailing-whitespace nil)
    (olivetti-mode 1)))
#+END_SRC

** fence-edit

Add fence regex for Python block strings.

#+begin_src emacs-lisp
  (add-to-list 'fence-edit-blocks
      '("\"\"\"" "\"\"\"" 1))
#+end_src

* Monkey Patching
** isearch Advice

This advice modifies isearch such that it will always auto-wrap
whenever a match is not found between point and the end of the buffer.

#+BEGIN_SRC emacs-lisp
(defadvice isearch-search (after isearch-no-fail activate)
  "Autowrap searches."
  (unless isearch-success
    (ad-disable-advice 'isearch-search 'after 'isearch-no-fail)
    (ad-activate 'isearch-search)
    (isearch-repeat (if isearch-forward 'forward))
    (ad-enable-advice 'isearch-search 'after 'isearch-no-fail)
    (ad-activate 'isearch-search)))
#+END_SRC

This advice causes isearch, the split-window-*, compilation mode, etc,
functions to recenter the buffer. This means less time spent searching
for the cursor, without having a distracting cursor design.

#+BEGIN_SRC emacs-lisp
(defun my:maybe-recenter ()
  "Recenter, unless it will cause an error in C-code. See recenter definition in window.c"
  (interactive)
  (when (equal (window-buffer) (current-buffer))
    (recenter)))

 (defadvice isearch-forward
    (after isearch-forward-recenter activate)
    (my:maybe-recenter))

(defadvice isearch-repeat-forward
  (after isearch-repeat-forward-recenter activate)
  (my:maybe-recenter))

(defadvice isearch-repeat-backward
  (after isearch-repeat-backward-recenter activate)
  (my:maybe-recenter))

(defadvice isearch-printing-char
  (after isearch-printing-char-then-recenter activate)
  (my:maybe-recenter))

(defadvice split-window-below
  (after split-window-below-recenter activate)
  (my:maybe-recenter))

(defadvice split-window-left
  (after split-window-left-recenter activate)
  (my:maybe-recenter))

(defadvice split-window-right
  (after split-window-right-recenter activate)
  (my:maybe-recenter))

(defadvice split-window-above
  (after split-window-above-recenter activate)
  (my:maybe-recenter))

(defadvice compile-goto-error
  (after compile-goto-error-then-recenter activate)
  (my:maybe-recenter))
#+END_SRC

If I want to quit a search, let me. What a weird default.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'search-nonincremental-instead nil)
#+END_SRC

** diff-hl Triggers

Whenever a file in version control is opened, enable diff-hl mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook
  (lambda ()
    (when (vc-backend (buffer-file-name))
        (diff-hl-mode)
        (diff-hl-update))))
#+END_SRC

Whenever a file is saved, make sure diff-hl is force updated.
TODO: This probably shouldn't be needed?

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
  (lambda ()
    (when (or
            (and (boundp 'diff-hl-mode) diff-hl-mode)
            (and (boundp 'diff-hl-amend-mode) diff-hl-amend-mode))
      (diff-hl-update))))
#+END_SRC

** find-file

Yes, I do want to create the directories....

#+BEGIN_SRC emacs-lisp
(defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
  "Create parent directory if not exists while visiting file."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir)))))
#+END_SRC

** ob-ipython

Add an interactive function to clean up unused files from the resource
directory.

#+BEGIN_SRC emacs-lisp
(defun my:org-buffer-links ()
  "https://emacs.stackexchange.com/questions/16909/how-can-i-get-all-file-links-in-one-org-mode-file"
  (org-element-map (org-element-parse-buffer) 'link
    (lambda (link)
      (when (string= (org-element-property :type link) "file")
        (org-element-property :path link)))))

(defun my:ob-ipython-clean-resource-dir ()
  "Delete files in `ob-ipython-resources-dir' which are not linked to in the current buffer.
This assmes that the directory is dedicated to the current buffer, which will NOT be the case
if your path is an absolute path, or if you have multiple org files in the same directory."
  (interactive)
  (let*
      ((links        (my:org-buffer-links))
       (files        (mapcar
                       (lambda (x) (concat ob-ipython-resources-dir x))
                       (seq-filter (lambda (x) (not (file-directory-p x))) (directory-files ob-ipython-resources-dir))))
       (unused-files (seq-filter (lambda (x) (not (cl-member x links :test #'string-match-p))) files)))
    (dolist (unwanted-file unused-files)
      (delete-file unwanted-file))))
#+END_SRC

Work around obi [[https://github.com/gregsexton/ob-ipython/issues/135][issue 135]].

#+BEGIN_SRC emacs-lisp
; kill extraneous content in ipython returns between top-level JSON objects
(advice-add 'ob-ipython--collect-json :before
            (lambda (&rest args)
              (let ((start (point)))
                (set-mark (point))
                (while (re-search-forward "{" nil t)
                  (backward-char)
                  (kill-region (region-beginning) (region-end))
                  (re-search-forward "}\n" nil t)
                  (set-mark (point)))
                (end-of-buffer)
                (kill-region (region-beginning) (region-end))
                (goto-char start))))
#+END_SRC

Remove the "# Out[%d]" stuff from the formatted output. It prevents named result blocks from correctly associating with =#+ATTR_LATEX:= lines, and I'm not sure that it has any functional purpose.

#+BEGIN_SRC emacs-lisp
(defun ob-ipython--process-response (ret file result-type)
  (let ((result (cdr (assoc :result ret)))
        (output (cdr (assoc :output ret))))
    (if (eq result-type 'output)
        output
      (ob-ipython--output output nil)
      (s-concat
       (s-join "\n" (->> (-map (-partial 'ob-ipython--render file)
                               (list (cdr (assoc :value result))
                                     (cdr (assoc :display result))))
                         (remove-if-not nil)))))))
#+END_SRC

** magit

Magit doesn't play nicely with Gerrit by default. Workaround from [[https://emacs.stackexchange.com/questions/19672/magit-gerrit-push-to-other-branch][StackOverflow]]. Modified to specify remote branch as well (master, features/xyz, etc).

#+BEGIN_SRC emacs-lisp
(defun magit-push-to-gerrit (source dest)
  "Push an arbitrary branch or commit to refs/for/someting on gerrit. The source and dest are read in the minibuffer."
  (interactive
   (let ((source (magit-read-local-branch-or-commit "Push"))
         (dest   (magit-read-remote-branch "To")))
     (list source dest)))
  (magit-git-command-topdir (concat "git push origin " source ":refs/for/" (string-join (remove "origin" (split-string dest "/")) "/"))))

(transient-append-suffix 'magit-push "m" '("g" "Push to gerrit" magit-push-to-gerrit))
#+END_SRC

** Emacs

When killing emacs, ask to save the desktop. I don't want this done by default, and I want to load the saved desktop only manually (so, no =desktop-save-mode=).

#+BEGIN_SRC emacs-lisp
(add-hook 'kill-emacs-hook (lambda () (interactive) (when (y-or-n-p "Save Desktop?") (desktop-save-in-desktop-dir))))
#+END_SRC

* OS Integration

** EXWM

Support for using EXWM (Emacs X-Window Manager). :) Though, I've
switched to StumpWM for the time being.

#+BEGIN_SRC emacs-lisp
(defun my:launch-de()
    "Modified from code here: http://doc.rix.si/cce/cce-exwm.html"
    (package-require 'exwm)
    (package-require 'exwm-systemtray)
    (package-require 'exwm-edit)
    (package-require 'clipmon)
    (clipmon-mode-start)
    (exwm-enable)
    (defun exwm-rename-buffer ()
      (interactive)
      (exwm-workspace-rename-buffer
       (concat exwm-class-name ":"
               (if (<= (length exwm-title) 50) exwm-title
                 (concat (substring exwm-title 0 49) "...")))))

    ;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
    (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
    (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)
    (setq window-divider-default-right-width 4)
    (window-divider-mode t)
    (exwm-systemtray-enable))
    ;(setq exwm-manage-configurations '((t char-mode t))))
#+END_SRC

* Notes & Vestigial Code

Notes are addressed to myself & my own use-cases.

** Using Emacs in WSL

Emacs for Windows works extremely well, but still have constant hangs and crashes. Using Emacs for Linux in WSL (on Windows >=10) solves most of these issues (while creating a few others..).

1. Install the Microsoft Ubuntu image. There's a third-party Arch image which works for the most part, but it's been less stable. The Ubuntu image is secure, verified, and maintained by Microsoft.
2. Make paths more MSYS/MINGW/GitForWindows compatible with =ln -s /mnt/c /c=.
3. Install =fish=, =build-essential=, and whatever other system apps I use.
4. Build emacs from the git mirror, unless you want a very old build. Not needed if using the Arch image. Make sure to use the GTK and ImageMagick switches. At time of writing, enabling XWidgets causes a compilation error due to missing typenames (something related to Lisp/JS interop?). Enabling cairo seems to be fine.
5. Install and configure Anaconda. Create the py36_64 environment. Install the jedi module.
6. Configure =xmodmap= like in Linux, as discussed in the Key Mappings section.
7. Install =fonts-noto= and =fonts-liberation=, =silversearcher-ag=, and whatever else is needed.
8. Install =vcxsrv= on Windows and run it.
9. Mount network shares like =sudo mount -t drvfs '\\blah.com\SHARE' /mnt/blah=. Save any recurring mounts in ~/mount-drives.sh. TODO: fstab?
10. Save the script below as =runemacs.sh=. It will run GUI emacs in the py36_64 conda env.
11. Kindly ask IT, just one more time, to let you install native Linux. :)

#+BEGIN_SRC sh
#!/bin/bash
export DISPLAY=localhost:0
export GDK_SCALE=0.5
export GDK_DPI_SCALE=2
xmodmap ~/.Xmodmap
xset r rate 200 60
bash ~/mount-drives.sh # drvfs commands, though tbh fstab would probably be better.
source activate py36_64 # Use the python interpreter that I control, not the system's.
#sudo service dbus start # DON'T do this, it doesn't set environment variables right in WSL
export $(dbus-launch) # For whatever reason, systemd doesn't work like this does
export $(gnome-keyring-daemon) # run secret-tool store --label="Test" test test once to trigger wallet creation
emacs --debug-init
#+END_SRC

** Using Emacs as a Service

Emacs can take some time to start up. Especially if you're loading over around 500 *.org files every time....

Write this to =~/.config/systemd/user/emacs.service=, then use emacs via =emacsclient= for (basically) instant startups. You'll need to change the path to =emacs= and =emacsclient= if you didn't compile it yourself -- they should match src_sh{which emacs}.

Don't forget to src_sh{systemctl enable --user emacs} and src_sh{systemctl start --user emacs}.

#+BEGIN_SRC
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=/usr/local/bin/emacs --daemon
ExecStop=/usr/local/bin/emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure

[Install]
WantedBy=default.target
#+END_SRC

Now, to edit a file with =emacs= from the command line, you'll want to use =emacsclient -c=. It's faster to use an alias.

Bash:

#+begin_src sh
alias e="emacsclient -c"
#+end_src

Fish:

#+begin_src fish
alias e="emacsclient -c"
#+end_src

** Using emacs as the default editor

In Bash and similar shells:

#+BEGIN_SRC sh
export ALTERNATE_EDITOR=""
export EDITOR="emacsclient -c"
export VISUAL="emacsclient -c -a emacs"
#+END_SRC

In Fish:

#+BEGIN_SRC fish
set -Ux EDITOR "emacsclient -c"
set -Ux VISUAL "emacsclient -c -a emacs"
#+END_SRC

Substitute =-c= for =-t= if you like that sort of thing.
